##### vue/cli 脚手架 2 创建项目命令

​ vue init webpack project-name

##### vue/cli 脚手架 3 创建项目命令

​ vue create project-name

##### style 标签中引入样式 css 文件

​ @import url(‘路径’)

##### 去除图片下面默认的 3px

​ vertical-align: middle;

##### 插槽 slot 外面最好套一层 div，把相关的 class 类等放在外层 div 里面，防止插槽被替换时相关的 class 也没有了。

##### 路由懒加载

​ const Home = ( ) => import('../views/home/Home')

##### 关于 vue 脚手架创建的项目路径起别名的问题

​ @代表 src 路径，给路径起别名时，通过 import 导入文件时不需要在路径前面加~，在标签中通过属性（src）引入路径时需要在路径前面加上~。

##### 通过下面方式创建的实例 instance 本身就是一个 Promise 对象，可以用.then()方法获取数据，.catch()方法获取错误信息

​ const instance = axios.create({baseURL: '', timeout: 5000})

​ instance(config).then(res => { }).catch(err => { })

##### 创建项目远程到 github 指令

1. 创建 github 仓库
2. cd 到项目目录下，输入指令：git remote add origin 'github 仓库地址'
3. git push -u origin master
4. 之后每次提交代码就输入：git add . --- git commit -m '备注信息' --- git push
5. 创建新分支并切换到该分支：git checkout -b 新分支名字
6. 查看所有分支：git branch
7. 查看状态：git status
8. 切换分支：git checkout 分支名字
9. 合并分支：git merge 要合并的分支名字

##### 项目的两个 css 文件初始样式表

​ base.css 和 normalize.css（可在 github 上直接搜索得到）

##### 项目中为路径起别名需要新建一个 vue.config.js 文件，内容如下

```javascript
module.exports = {
  configureWebpack: {
    resolve: {
      alias: {
        assets: "@/assets",
        common: "@/common",
        components: "@/components",
        network: "@/network",
        views: "@/views",
      },
    },
  },
}
```

##### <%= BASE_URL %>表示动态获取当前文件所在的目录

##### 监听组件根元素的原生事件

​ 在我们需要监听一个组件的原生事件时，必须给对应的事件加上.native 修饰符，才能进行监听

​ <back-top @click.native='itemClick' />

##### 关于 ref

​ ref 如果是绑定在组件中的，那么通过 this.$refs.refname 获取到的是一个组件对象

​ ref 如果是绑定在普通元素中的，那么通过 this.$refs.refname 获取到的是一个元素对象

##### 事件总线（非父子组件传值）

​ 在 main.js 文件中设置事件总线 Vue.prototype.$bus = new Vue() Vue 实例是可以作为事件总线的

​ 在事件总线上发送事件 this.$bus.$emit('事件名称', 参数)

​ 在事件总线上接收事件 this.$bus.$on('事件名称', 回调函数(参数))

​ 取消全局事件的监听 this.$bus.$off('事件名称', 回调函数(参数))

​ Vue3 中使用 mitt 实现全局事件总线（非父子组件传值）

##### 监听图片加载完成

​ 原生的 js 监听图片：img.onload = function(){ }

​ Vue 中监听图片：<img @load='方法名称'>

##### 防抖函数和节流函数

​ 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。

​ 触发高频函数事件后，n 秒内函数只能执行一次，如果在 n 秒内这个事件再次被触发的话，那么会重新计算时间。

```javascript
methods: {
    debounce(func, delay){
        let timer = null
        return funtion(...args){
            if(timer) clearTimeout(timer)
            timer = setTimeout(() => {
                func.apply(this, args)
            }, delay)
        }
	}
},
mounted(){
    const refresh = this.debounce(this.$refs.scroll.refresh, 500)
    //使用防抖函数监听图片加载，如果在500ms之内又有图片加载了则把上一个定时器取消掉，重新开启一个新的定时器
    //直到500ms内不再有新的图片加载出来，则执行最后的func函数。
    //refresh不会被销毁，因为refresh()形成了闭包
    this.$bus.$on('itemImageLoad', () => {
        refresh()
	})
}
```

​ 函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

​ 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率

```javascript
funtion throttle(func, delay){
    let timer = null
    return function(...args){
        if(!timer){
            timer = setTimeout(() => {
                func.apply(this, args)
                timer = null
            }, delay)
        }
    }
}
```

##### 所有组件都有一个属性$el：用于获取组件中的元素

​ this.$refs.tabControl.$el.offsetTop （tabControl 是一个组件对象）

##### 项目中很多组件中都需要使用的东西可以使用混入 mixin 抽离出来

​ 在单独的文件中创建混入对象：const mixin = {}

​ 组件对象中使用：mixins: [mixin]

##### 该函数的作用就是根据最新的数据，对应的 DOM 被渲染出来之后，再执行回调函数的代码

​ this.$nextTick(回调函数)

​ this.$nextTick(( ) => { })

##### 关于 vuex

​ 不能直接修改任何 state 里面的东西，而要通过 mutations 来修改 state 里面的属性

​ mutations 唯一的目的就是修改 state 中的状态，mutations 中的每个方法尽可能完成的事件比较单一一点。

​ actions 里面的方法可以返回一个 Promise，然后通过.then 方法接收要从 vuex 传到外面的结果，比如 this.$store.dispatch('addCart', payload)).then(res => {console.log(res)}

##### FastClick

​ FastClick 是专门为解决移动端浏览器 300ms 点击延迟问题所开发的一个轻量级的库

​ FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。

​ 使用方法：npm install fastclick --save

​ import FastClick from 'fastclick'

​ FastClick.attach()

##### vue-lazyload

​ 使用 vue 的 vue-lazyload 插件可以实现图片懒加载，即需要显示图片时再加载

​ 使用方法：npm install vue-lazyload --save

​ import VueLazyLoad from 'vue-lazyload'

​ Vue.use(VueLazyLoad, {

​ //图片没加载出来的占位符

​ loading: require('./assets/img/placeholder.png')

​ })

​ 然后在使用图片的地方将 src 属性改成 v-lazy

​ 将<img :src='showImg' > 改为 <img v-lazy='showImg' >

##### 使用插件自动将项目中的像素单位 px 转换为 vw

​ 使用方法：npm install postcss-px-to-viewport --save-dev

​ 修改 postcss.config.js 文件

##### 登陆功能的相关技术点

​ http 是无状态的

​ 如果前端与后台接口之间不存在跨域问题，则推荐使用通过 cookie 在客户端记录状态，通过 session 在服务端记录状态。

​ 如果前端与后台接口之间存在跨域问题，则推荐使用 token 方式维持状态。

​ 使用方法：将登陆成功之后的 token 保存到客户端的 sessionStorage 中

​ 项目中除了登陆之外的其他 API 接口，必须在登陆之后才能访问

​ token 只应在当前网站打开期间生效，所以将 token 保存在 sessionStorage 中

​ window.sessionStorage.setItem('token', res.data.token)

​ 路由导航守卫控制访问权限：如果用户没有登陆，但是直接通过 url 访问特定页面，需要重新导航到登录页面。

```javascript
//为路由对象，添加beforeEach导航守卫
router.beforeEach((to, from, next) => {
  //如果用户访问登录页，直接放行
  if (to.path === "/login") return next()
  //从sessionStorage中获取到保存的token值
  const tokenStr = window.sessionStorage.getItem("token")
  //没有token，强制跳转到登录页
  if (!tokenStr) return next("/login")
  next()
})
```

##### 退出功能实现原理

​ 基于 token 的方式实现退出比较简单，只需要销毁本地的 token 即可，这样后续的请求就不会携带 token，必须重新登陆生成一个新的 token 之后才可以访问页面。

```javascript
//清空token
window.sessionStorage.clear()
//跳转到登录页
this.$router.push("/login")
```

##### 验证手机号的规则（element ui）

```javascript
var checkMobile = (rule, value, cb) => {
  //验证手机号的正则表达式
  const regMobile = /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/
  if (regMobie.test(value)) {
    return cb()
  }
  cb(new Error("请输入合法的手机号"))
}
```

##### 验证邮箱的规则（element ui）

```javascript
var checkEmail = (rule, value, cb) => {
  //验证邮箱的正则表达式
  const regEmail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/
  if (regEmail.test(value)) {
    return cb()
  }
  cb(new Error("请输入合法的邮箱"))
}
```

##### 面试前，练习回答自己项目的三个问题

- 这是一个怎样的项目
- 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）
- 过程中遇到了什么问题，怎么解决的

##### 实现动画效果的方式

- javascript 直接实现

  ```javascript
  <body>
       <div id="rect"></div>
       <script>
           let elem = document.getElementById('rect');
           let left = 0;
           let timer = setInterval(function(){
               if(left<window.innerWidth-200){
                   elem.style.marginLeft = left+'px';
                   left ++;
               }else {
                   clearInterval(timer);
               }
           },16);
       </script>
   </body>
  ```

- css3 transition

  ```javascript
  transition: property duration timing-function delay;
  ```

- css3 animation

  ```javascript
  animation: name duration timing-function delay iteration-count direction;
  ```

- requestAnimationFrame

  ```javascript
  <body>
       <div id="rect"></div>
       <script type="text/javascript">
       window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||
       window.msRequestAnimationFrame;

       let elem = document.getElementById("rect");
       //自动执行持续性回调
       requestAnimationFrame(step);
       //持续该改变元素位置
       function step() {
           if(left<window.innerWidth-200){
               left+=1;
               elem.style.marginLeft = left+"px";
               requestAnimationFrame(step);
           }
       }
       </script>
   </body>
  ```

- canvas 动画

- svg

##### 兼容性问题

- 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的`*{margin:0;padding:0;}`来统一。

- IE 下,even 对象有`x`,`y`属性,但是没有`pageX`,`pageY`属性;Firefox 下,event 对象有`pageX`,`pageY`属性,但是没有`x`,`y`属性。

  ```javascript
  //解决方案：
  var page = {}
  page.x = event.x ? event.x : event.pageX
  page.y = event.y ? event.y : event.pageY
  ```

- IE 下,可以使用获取常规属性的方法来获取自定义属性,也可以使用`getAttribute()`获取自定义属性;Firefox 下,只能使用`getAttribute()`获取自定义属性。解决方法:统一通过`getAttribute()`获取自定义属性。

- 图片默认有间距。解决办法：使用 float 属性为 img 布局。

##### em 和 rem 的区别

​ px 是固定的像素，一旦设置了就无法因为适应页面大小而改变。

em 和 rem 相对于 px 更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

​ 对于 em 和 rem 的区别一句话概括：**em 相对于父元素，rem 相对于根元素。**

##### 前端开发几种布局方式

- 静态布局：给页面元素设置固定的宽度和高度，单位用 px，当窗口缩小，会出现滚动条，拉动滚动条显示被遮挡内容。针对不同分辨率的手机端，分别写不同的样式文件。
- 弹性布局： css3 引入的，flex 布局；优点在于其容易上手，根据 flex 规则很容易达到某个布局效果，然而缺点是：浏览器兼容性比较差，只能兼容到 ie9 及以上；
- 流式布局： 元素的宽高用百分比做单位，元素宽高按屏幕分辨率调整，布局不发生变化。屏幕尺度跨度过大的情况下，页面不能正常显示。
- 响应式布局： <meta name=”viewport” content=”divice-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no”> 使用 meta 标签设置，页面元素宽度随窗口调整自动适配。

##### for of 和 for in 的区别

```javascript
var arr = ["a", "b", "c"]
Array.prototype.hello = "d"
for (item of arr) {
  console.log(item)
} //a b c

for (item in arr) {
  console.log(item)
} //0 1 2 hello
```

- `of` 遍历的是数组的项,而`in`遍历的是数组的属性,索引,`in` 不仅仅会遍历自身属性,还会遍历所有通过继承原型链的对象下的属性。
- of 可以用于遍历数组，不能遍历对象。

##### transform 属性

​ transform：none | translate(_x_,_y_) | scale(_x_,_y_) | rotate(_angle_) | translateX(_x_) | scaleY(_y_) | rotateZ(_angle_) | translate3d(_x_,_y_,_z_) | scale3d(_x_,_y_,_z_) | rotate3d(_x_,_y_,_z_,_angle_)

##### js 获取 dom 节点的方法

- 通过 ID 获取（getElementById）
- 通过 name 属性（getElementsByName）
- 通过标签名（getElementsByTagName）
- 通过类名（getElementsByClassName）
- 通过选择器获取一个元素（querySelector）
- 通过选择器获取一组元素（querySelectorAll）
- 获取 html 元素的方法（document.documentElement）
- 获取 body 元素的方法（document.body）

##### http 常见的请求头和响应头

常见的请求头：

Accept: text/html,image/\* -- 浏览器接受的数据类型

Accept-Charset: ISO-8859-1 -- 浏览器接受的编码格式

Accept-Encoding: gzip,compress --浏览器接受的数据压缩格式

Accept-Language: en-us,zh- --浏览器接受的语言

Host: www.it315.org:80 --（必须的）当前请求访问的目标地址（主机:端口）

If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT --浏览器最后的缓存时间

Referer: http://www.it315.org/index.jsp -- 当前请求来自于哪里

User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) --浏览器类型

Cookie:name=eric -- 浏览器保存的 cookie 信息

Connection: close/Keep-Alive -- 浏览器跟服务器连接状态。close: 连接关闭 keep-alive：保存连接。

Date: Tue, 11 Jul 2000 18:23:51 GMT -- 请求发出的时间
Content-Length -- 设置请求体的字节长度
Cache-Control -- 设置请求响应链上所有的缓存机制必须遵守的指令

常见的响应头：

Location: http://www.it315.org/index.jsp -表示重定向的地址，该头和 302 的状态码一起使用。

Server:apache tomcat ---表示服务器的类型

Content-Encoding: gzip -- 表示服务器发送给浏览器的数据压缩类型

Content-Length: 80 --表示服务器发送给浏览器的数据长度

Content-Language: zh-cn --表示服务器支持的语言

Content-Type: text/html; charset=GB2312 --表示服务器发送给浏览器的数据类型及内容编码

Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT --表示服务器资源的最后修改时间

##### top left 定位和 transform 的区别

​ 最首要的区别是元素位置：使用 top left 定位是直接改变元素真实位置的，简单来说你 top: 5px 那就真的是离父容器上端 5px 或者偏离顶部定位 5px；但是你用 transform: translateY(-5px) 只是改变了视觉位置，元素本身位置还是在 0px，只是视觉上向上偏移了 5px。

​ 最后的区别是效率：由于 transform 不改动 css 布局，因为渲染行为大多数情况下在元素本身，所以效率比 top left 要高。

##### 清空队列的方法

- arr = []
- arr.length = 0
- arr.splice(0, arr.length)

##### css 盒模型

​ 就是用来装页面上的元素的矩形区域，包括标准盒模型和 IE 盒模型。

​ 标准盒模型与 IE 盒模型的区别在于宽高的计算方式不同。

​ 标准盒模型计算元素的宽高只算 content 的宽高，IE 盒模型是 content + padding + border 的总尺寸。

​ 如何设置这两种模型：

​ box-sizing: content-box; 设置标准盒模型，width 和 height 只包括 content 的宽高，不包括 border，padding，margin。

​ box-sizing: border-box; 设置 IE 盒模型，width 和 height 包括 content,padding 和 border，不包括 margin。

##### js 如何设置和获取盒模型的宽和高

​ 假设已经获取的节点为 dom

```javascript
//只能获取使用内联样式的元素的宽和高
dom.style.width / height
//这种方法获取的是浏览器渲染以后的元素的宽和高，这种写法兼容性更好一些。
window.getComputedStyle(dom).width / height
//这种方法获取的是浏览器渲染以后的元素的宽和高，无论是用何种方式引入的css样式都可以，但只有IE浏览器支持这种写法。
dom.currentStyle.width / height
//这种方式获得到的宽度是内容content+padding+border
//此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。
//此 api 可以拿到六个属性：left、top、right、bottom、width、height。
dom.getBoundingClientRect().width / height
```

##### 画一条 0.5px 的线

- 采用 meta viewport 的方式（viewport 只针对移动端，只在移动端上才能看到效果）

  `<meta name="viewport" content="width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5"/>`

- 采用 transform: scale()的方式

  `transform: scale(0.5,0.5);`

##### link 标签和 import 标签的区别

​ link 属于 html 标签，而@import 是 css 提供的

​ 页面被加载时，link 会同时被加载，而@import 引用的 css 会等到页面加载结束后加载。

​ link 是 html 标签，因此没有兼容性，而@import 只有 IE5 以上才能识别。

​ link 方式样式的权重高于@import 的。

##### transition 和 animation 的区别

​ 1、transition 是过渡，是样式值的变化的过程，只有开始和结束；animation 其实也叫关键帧，通过和 keyframe 结合可以设置中间帧的一个状态；

2、animation 配合 @keyframe 可以不触发时间就触发这个过程，而 transition 需要通过 hover 或者 js 事件来配合触发；

3、animation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次；

4、animation 可以结合 keyframe 设置每一帧，但是 transition 只有两帧；

5、在性能方面：浏览器有一个主线程和排版线程；主线程一般是对 js 运行的、页面布局、生成位图等等，然后把生成好的位图传递给排版线程，而排版线程会通过 GPU 将位图绘制到页面上，也会向主线程请求位图等等；我们在用使用 aniamtion 的时候这样就可以改变很多属性，像我们改变了 width、height、postion 等等这些改变文档流的属性的时候就会引起，页面的回流和重绘，对性能影响就比较大，但是我们用 transition 的时候一般会结合 tansfrom 来进行旋转和缩放等不会生成新的位图，当然也就不会引起页面的重排了；

##### vue 项目文件结构

- README.md ：这是一个项目说明文件；
- package.json : 这是一个依赖包，也就是第三方模块依赖存放处（npm insatll 安装的所有包都显示在这里）；
- package-lock.json : 这是 package 的锁文件，确定安装的第三方包版本，为了统一团队的编码；
- LICRENSE ：开源协议的说明；
- index.html : 项目默认的首页模版文件，（单页面入口文件，相当于一个大框架其它页面都是填在这个页面的）；
- .postcssrc : postcss 配置文件，PostCSS 是一个用 javascript 转换 CSS 的工具，有了它可放心使用 CSS 未来的语法等
- .gitignore : git 上传需要忽略的文件格式
- .eslintrc.js：ESlint 的语法检测规则定义
- .eslintignore：忽略项目中某个文件夹的提交规范
- .editorconfig：定义代码格式
- .babelrc：ES6 语法编译配置
- main.js：项目入口文件，加载各种公共组件
- APP.vue : 项目的最原始的根组件（项目的入口文件）；
- node_module : 项目依赖的第三方 node 包，这个里面内容可以不用管，只要知道是放的依赖包。

##### localstorage 是什么，它有哪些作用

​ localstorage 作为 h5 本地存储 web storage 特性的 api 之一，主要作用就是将数据保存在客户端中。

​ localStorage 保存的数据，一般情况下是永久保存的，也就是说只要采用 localstorage 保存信息，数据便一直存储在用户的客户端中。即使用户关闭当前 web 浏览器后重新启动，数据仍然存在。直到用户手动删除，数据的生命周期才会结束。

##### BFC

​ 块级格式化上下文，它是指一个独立的块级渲染区域，只有块级盒子参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。

​ BFC 的布局规则：

​ Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。

​ 内部的 Box 会在垂直方向，一个接一个地放置。

​ BFC 区域不会与 float box 重叠

​ BFC 是页面上的一个独立容器，子元素不会影响到外面

​ 计算 BFC 的高度时，浮动元素也会参与计算

​ 如何创建 BFC：

- float 的值不是 none
- position 的值不是 static 或者 relative
- display 的值是 inline-block、flex、inline-flex、table-cell、table-caption
- overflow 的值不是 visible

​ BFC 的作用：

- 避免 margin 重叠
- 自适应两栏布局
- 清除浮动

##### 数组扁平化

- 数组自带的扁平化方法

  ```javascript
  const arr = [1, [2, [3, [4, 5]]], 6]
  console.log(arr.flat(Infinity))
  ```

- 递归

  ```javascript
  let newArr = []
  function fn(arr) {
    for (let i = 0; i < arr.length; i++) {
      if (Array.isArray(arr[i])) {
        fn(arr[i])
      } else {
        newArr.push(arr[i])
      }
    }
  }
  const arr = [1, [2, [3, [4, 5]]], 6]
  fn(arr)
  console.log(newArr)
  ```

- reduce

  ```javascript
  const newArr = (arr) => {
    return arr.reduce((prev, cur) => {
      return prev.concat(Array.isArray(cur) ? newArr(cur) : cur)
    }, [])
  }
  ```

##### reduce 使用

- 计算数组中每个元素出现的个数

  ```javascript
  let person = ["htt", "htt", "nyy", "zz"]
  let nameNum = person.reduce((pre, cur) => {
    if (cur in pre) {
      pre[cur]++
    } else {
      pre[cur] = 1
    }
    return pre
  }, {})
  ```

- 数组去重

  ```javascript
  //1
  let arr = [1, 2, 3, 4, 1, 2, 3, 4]
  let newArr = arr.reduce((pre, cur) => {
    if (pre.includes(cur)) {
      return pre
    } else {
      return pre.concat(cur)
    }
  }, [])
  //2
  function unique(arr) {
    let newArr = []
    for (let item of arr) {
      if (newArr.indexOf(item) == -1) {
        newArr.push(item)
      }
    }
    return newArr
  }
  ```

##### 元素水平垂直居中

```javascript
//absolute+负margin
//这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高
<div class="out">
  <div class="inner">12345</div>
</div>

<style type="text/css">
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 50%;
    top: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
</style>
```

```javascript
//absolute+auto margin
//这种方法兼容性也很好，缺点是需要知道子元素的宽高
<style type="text/css">
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }
</style>
```

```javascript
//absolute+calc
//这种方法的兼容性依赖于 calc，且也需要知道宽高
<style type="text/css">
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    width: 100px;
    height: 100px;
    background: yellow;
    left: calc(50% - 50px);
    top: calc(50% - 50px);
  }
</style>

```

```javascript
//absolute+transform
//兼容性依赖 translate，不需要知道子元素宽高
<style type="text/css">
  .out{
    position: relative;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    position: absolute;
    background: yellow;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
</style>
```

```javascript
//table
<style type="text/css">
  .out{
    display: table-cell;
    width: 300px;
    height: 300px;
    text-align: center;
    vertical-align: middle;
    background: red;
  }

  .inner{
    display: inline-block;
    background: yellow;
    width: 100px;
    height: 100px;
  }
</style>
```

```javascript
//flex
<style type="text/css">
  .out{
    display: flex;
    justify-content: center;
    align-items: center;
    width: 300px;
    height: 300px;
    background: red;
  }

  .inner{
    background: yellow;
    width: 100px;
    height: 100px;
  }
</style>
```

##### 关于 js 动画和 css3 动画的差异性

​ 功能涵盖面，js 比 css 大，复杂；js 在主线程中运行，容易丢帧；js 灵活，兼容性好；

​ 实现/重构难度不一，CSS3 比 js 更加简单， 性能跳优方向固定

​ 对帧速表现不好的低版本浏览器，css3 可以做到自然降级

​ css 动画有天然事件支持；浏览器可以对 css 动画进行优化

​ css 有兼容性问题，笨重，代码冗长；强制 gpu 加速

​ css 比 js 动画流畅的原理是因为在复合线程中进行动画处理，所以节省了昂贵的主线程资源

##### 关于 flex 布局 align-items 和 align-content 的区别

- align-items 属性适用于所有的 flex 容器，它是用来设置每个 flex 元素在侧轴上的默认对齐方式。align-items 和 align-content 有相同的功能，不过不同点是它是用来让每一个单行的容器居中而不是让整个容器居中。
- align-content 属性只适用于多行的 flex 容器，它的作用就是当 flex 容器在交叉轴上有多余的空间时，将子项作为一个整体进行对齐。

##### 块元素和行内元素

​ 块元素：独占一行，其宽度自动填满其父元素宽度，垂直向下排列，可以设置 margin 和 pading 以及高度和宽度

​ 行内元素：不会独占一行，设置宽高无效，宽高随内容的变化而变化，设置 padding，margin 上下无效左右有效。

​ 行内元素设置宽高的几种方式：

- 给内联元素转换成块元素 block 或行内块元素 inline-block
- 让内联元素脱离文档流，比如绝对定位，固定定位或浮动

##### cookie，localStorage，sessionStorage

cookie：数据存储，跨页面通讯；数据每次都会发送给服务端；cookie 是网站为了标示用户身份而储存在用户**本地终端**（Client Side）上的数据（通常经过加密）。
前后端都可以操作；参与服务器端通信，每次都会存在 http 的头信息中。
cookie 的默认是会话级别的有效期，即页面打开到页面关闭；但可以手动设置过期时间；
只要 cookie 里面有数据，请求的时候都会自动携带；
存储大小：4KB 左右，受 IE 的限制；cookie 有安全性问题。如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。cookie 的流程是：服务器设置 cookie---通过 response 将 cookie 传到前端保存在浏览器中---前端访问后端接口时在 request header 中自动添加上 cookie---服务端接收到 cookie 做一些业务操作。

localStorage:存储数据，跨页面通讯；
不会与服务器端通讯，相对与 cookie 较安全，不用担心数据被截获；
只能有前端操作，后端操作不了；不会与服务器端通讯，相对与 cookie 较安全，不用担心数据被截获；
存储的时效性是永久的，但是可以手动删除；
不管有没有数据，请求的时候都不会自动携带；
存储大小：5M 左右

sessionStorage：存储数据；
仅在当前会话下有效。sessionStorage 引入了“浏览器窗口”的概念。sessionStorage 是在同源的窗口中始终保存存在的数据。只要这个浏览器窗口关闭后就会被销毁；
存储大小：5M 左右；
不会与服务器端通讯，相对与 cookie 较安全，不用担心数据被截获；
也可以简单的理解为 sessionStorage 是没有设置有效期的 cookie，cookie 的有效期设置为永久，就是 localStorage。

cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。

token 和 cookie 都是为了解决 HTTP 协议无状态的问题

##### cookie 常用属性

- name：cookie 的名称
- value：cookie 的值
- expires：cookie 过期时间（具体时间）
- maxAge：cookie 最大失效时间（毫秒数）
- path：一个路径，在这个路径下面的页面才可以访问该 Cookie
- domain：子域，指定在该子域下才可以访问 Cookie
- secure：安全性，指定 Cookie 是否只能通过 https 协议访问
- HttpOnly：如果在 Cookie 中设置了"HttpOnly"属性，那么通过程序(JS 脚本、Applet 等)将无法读取到 Cookie 信息。该属性禁止 js 脚本使用 document.cookie 来访问 cookie

##### 普通函数和箭头函数的 this

- 普通函数的 this

  1. this 总是代表它的直接调用者, 例如 obj.func ,那么 func 中的 this 就是 obj
  2. 调用的时候，没有任何前缀，则指向 window，new 的时候，指向 new 出来的对象。
  3. 在默认情况(非严格模式下,未使用 'use strict'),没找到直接调用者,则 this 指的是 window

     4.在严格模式下,没有直接调用者的函数中的 this 是 undefined

     5.使用 call,apply,bind(ES5 新增)绑定的,this 指的是 绑定的对象

- 箭头函数的 this

  this 是静态的，始终指向函数声明时所在作用域下的 this 的值

##### promise 常用方法

​ then(), catch(), resolve()返回成功的值，reject()返回失败的值

```javascript
1. function aa(){
    var p = new Promise(function(resovle, reject){
      //做一些请求值的异步操作，例如：
      setTimeout(function(){
          var num = Math.ceil(Math.random()*10); //比如这是请求来的值
              if(num<=5){ //满足条件
                  resolve(num);
              }else{ //不满足条件
                  reject('数字太大了');
             }
      })
       })
    return p;
     }

   2. aa().then(function(data){
    //这里的data就是aa()方法得出数据
    return 接下来的方法
      }).catch(function(reason){
    //这里是抛出异常后执行的函数,这里reason就是抛出异常的提示信息
      })
```

all()方法：将加入 all 方法的所有 promise 对象返回的值归集到 then 方法里面统一展现

```javascript
Promise.all([aa(), bb(), cc()]).then(function (resulte) {
  //这里的resulte是包含了aa(), bb(), cc()返回值的一个数组
})
```

##### 三种变量声明方式

1. 使用 var 声明变量

2. 使用 let 声明变量

3. 使用 const 声明变量

   区别：

   - 变量初始化要求不同：var 和 let 声明变量时可以不需要初始化，没有初始化的变量的值为“undefined”，在代码的运行过程中变量的值可以被修改。const 声明变量时必须初始化，并且在代码的整个运行过程中不能修改初始化值，否则运行时会报错。
   - 变量提升的支持不同：var 声明支持变量提升，而 const 和 let 声明不支持变量提升。
   - 对块级作用域的支持不同：var 声明的变量，不支持块级作用域，let 和 const 声明的变量支持块级作用域。
   - 重复声明：在同一个作用域中，var 可以重复声明同一个变量，let 和 const 不能重复声明同一个变量。
   - let 和 const 存在暂时性死区（在代码块内，使用`let、const`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”）

##### 变量提升

- 变量声明提升：通过 var 声明的变量，在定义语句前就可以访问到；值：undefined
- 函数声明提升：通过 function 声明的函数，在之前就可以直接调用；值：函数定义

##### 预解析

​ 预解析就是：在当前作用域中，js 代码执行之前，浏览器首先会把默认的所有带 var 和 function 声明的变量进行提前的声明或者定义。

##### vue 项目怎么打包的，后期更新怎么办

​ **Vue**项目打包一般是基于**webpack+vue-cli**下的操作，具体的操作命令也很简单，只需要在终端里面输入打包命令：**npm run build** 回车即可进行打包。

##### webpack 中 loader 和 plugin 的区别

- loader

  由于 webpack 本身只能打包 commonjs 规范的 js 文件，所以，针对 css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。loader 主要就是完成压缩，打包，语言翻译。loader 运行在打包文件之前。

  如：css-loader 和 style-loader 模块是为了打包 css 的

  babel-loader 和 babel-core 模块时为了把 ES6 的代码转成 ES5
  url-loader 和 file-loader 是把图片进行打包的。

- plugin

  plugin 也是为了扩展 webpack 的功能，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。plugins 在整个编译周期都起作用。

  如：针对 html 文件打包和拷贝（还有很多设置）的插件：html-webpack-plugin。

  ​ CommonsChunkPlugin 是一个可以用来提取公共模块的插件。

##### webpack 的原理

​ webpack 是一个打包模块化 js 的工具，可以通过 loader 转换文件，通过 plugin 扩展功能。

​ webpack 是把项目当作一个整体，通过给定的一个主文件，webpack 将从这个主文件开始找到你项目当中的所有依赖的文件，使用 loaders 来处理它们，最后打包成一个或多个浏览器可识别的 js 文件。

##### web 端如果要实现按钮事件的绑定是怎么做?

- element.onclick = function(){ }
- _element_.addEventListener(_event_, _function_, _useCapture_)

##### addEventListener 有几个参数?

​ _element_.addEventListener(_event_, _function_, _useCapture_) 三个参数

```javascript
document.getElementById("myBtn").addEventListener("click", function () {
  document.getElementById("demo").innerHTML = "Hello World"
})
```

- event: 指定事件名，不含“on”
- function：指定事件触发时执行的函数
- useCapture：为 true 时表示事件在捕获阶段时执行，默认为 false 表示事件在冒泡阶段执行。

​ 移除事件：_element_.removeEventListener(_event_, _function_, _useCapture_)

##### addEventListener 有兼容性的问题吗?那 IE 响应的是什么方法 ?

​ 有兼容性问题

​ IE 响应方法是 _element_.attachEvent(_event_, _function_)

- event: 指定事件名，含“on”

- function：指定事件触发时执行的函数

​ 移除事件：_element_.detachEvent(_event_, _function_)

##### 用事件委托在点击时是怎么获取到点击对象的？有兼容性问题吗

​ event.target || event.srcElement

```javascript
window.onload = function () {
  var oUl = document.getElementById("ul1")
  oUl.onclick = function (ev) {
    var ev = ev || window.event
    var target = ev.target || ev.srcElement
    if (target.nodeName.toLowerCase() == "li") {
      alert(123)
      alert(target.innerHTML)
    }
  }
}
```

##### 事件委托的好处

- 提高 JavaScript 性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。
- 动态的添加 DOM 元素，不需要因为元素的改动而修改事件绑定。

##### js 原生创建一个标签怎么做? appendchild 是谁调用?

​ 1、创建元素：Document.createElement()

​ 2、找到父级元素 ：可以通过 Id、name、标签名、class、匹配指定的 css 选择器

​ 3、在指定位置插入元素：element.appendChild()、element.insertBefore()

##### js 如果要加 100 个标签怎么办

```javascript
<body>
    <div id='box'></div>
	<script>
        var box = document.getElementById('box')
		var str = ''
        for(var i=0; i<100; i++){
            str += '<div>' + (i+1) + '</div>'
        }
		box.innerHTML = str
    </script>
</body>
```

##### 重排

​ 当 DOM 的变化引发了元素几何属性的变化，比如`改变元素的宽高`，`元素的位置`，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。

##### js 添加和移除 class 类名的方法

- 添加 class：element.classList.add('className')
- 移除 class：element.classList.remove('className')

##### 不改变原数组的方法

​ slice，concat，join，toString

##### 改变原数组的方法

- pop：删除数组最后一个元素，并返回该元素
- push：在数组尾部添加元素，并返回更新后的数组长度
- shift：删除数组的第一个元素，并返回该元素
- unshift：在数组第一位添加元素，并返回更新后的数组长度
- sort：对数组排序
- reverse：数组反转
- splice：返回被删除元素所组成的数组

##### Set

​ Set 转换为数组的方法：

```javascript
const set = new Set([1, 2, 3, 4, 4, 4])
//第一种方法
var arr = [...set]
//第二种方法
var arr = Array.from(set)
```

​ Set 的遍历方法有四个：

​ keys()：返回键名的遍历器

vaules()：返回键值的遍历器

entries()：返回键值对的遍历器

forEach()：使用回调函数遍历每个成员

```javascript
let set = new Set(["red", "green", "blue"])

for (let item of set.keys()) {
  console.log(item)
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item)
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item)
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]

let set = new Set([1, 4, 9])
set.forEach((value, key) => console.log(key + " : " + value))
// 1 : 1
// 4 : 4
// 9 : 9
```

##### Array.from()

​ Array.from 可以接受三个参数：

​ arrayLike：被转换的的对象。

​ mapFn：map 函数。

​ thisArg：map 函数中 this 指向的对象。

```javascript
Array.from(arrayLike[, mapFn[, thisArg]])
let diObj = {
  handle: function(n){
    return n + 2
  }
}
console.log('%s', Array.from(
  [1, 2, 3, 4, 5],
  function (x){
    return this.handle(x)
  },
  diObj))
```

##### 判断数组的方法

- arr instanceof Array
- Object.prototype.toString.call(arr)
- arr.constructor === Array
- Array.isArray(arr)

##### Map 和 object 的区别

​ 1.Object 对象有原型

​ 2.在 Object 对象中， 只能把 String 和 Symbol 作为 key 值， 但是在 Map 中，key 值可以是任何数据类型

##### cors 具体设置

​ 浏览器将 CORS 请求分成两类:简单请求（simple request）和非简单请求（not-so-simple request）

- 简单请求

  一般满足以下两大条件：1.请求方法是 head，get，post；2.http 头信息不超过以下几种字段：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type。

  对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。

  ```javascript
  add_header 'Access-Control-Allow-Origin': '*';
  add_header 'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE';
  add_header 'Access-Control-Allow-Headers': 'Content-Type';
  ```

  在 nginx 上经以上配置，一般能够解决简单请求的跨域处理。
  CORS 请求默认不发送 Cookie 和 HTTP 认证信息。但是如果要把 Cookie 发到服务器，要服务器同意，指定 Access-Control-Allow-Credentials 字段。

  ```javascript
  add_header 'Access-Control-Allow-Credentials': 'true';
  ```

  需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。

- 非简单请求

  非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT、DELETE 或 OPTIONS，或者 Content-Type 字段的类型是 application/json。非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求（preflight），**预捡的请求方法是 OPTIONS**。

  若头信息中有 OPTIONS 方法，说明此次 CORS 请求是非简单请求，需要在 nginx 中添加头:

  ```javascript
  add_header 'Access-Control-Allow-Origin': '*';
  add_header 'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE';
  add_header 'Access-Control-Allow-Headers': 'Content-Type';
  ```

  此时虽然我们已经添加了所有的 Methods 方法，但是预检请求仍不会通过，因此此时 nginx 对 OPTIONS 方法返回"405 Method Not Allowed”或者 403。我们需要在 nginx 对 OPTIONS 方法进行处理，如下：

  ```javascript
  if($request_method = 'OPTIONS'){
      add_header 'Access-Control-Allow-Origin': '*';
  	add_header 'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE';
  	add_header 'Access-Control-Allow-Headers': 'Content-Type';
      return 200;
  }
  ```

##### get 和 post 的区别

​ get 请求不能在 request body 中传递参数。

​ HTTP 协议未规定 GET 和 POST 的长度限制，GET 的最大长度限制是因为浏览器和 web 服务器限制了 URI 的长度，不同的浏览器和 WEB 服务器，限制的最大长度不一样。

- get 参数通过 URL 传递；post 放在 request body 中

- get 请求在 URL 中传递的参数有长度限制；post 没有（HTTP 协议未规定，是因为浏览器和服务器的限制）

- get 请求只能进行 URL 编码；post 请求有多种编码方式

- get 请求参数会被完整保留在浏览历史记录里；post 中的参数不会被保留

- get 产生一个 TCP 数据包；post 产生两个 TCP 数据包

- 对于 get 请求，浏览器将 http header 和 data 一并发送，服务器响应 200 OK；对于 post 请求，浏览器先发送 header，服务器响应 100 Continue，浏览器再发送 data，服务器响应 200 OK

- 缓存方面：get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以

使用缓存；post 请求一般做的是修改和删除工作，必须与数据库交互，所以不能使用缓存

##### fetch

​ fetch 获取资源会返回一个 promise 对象，所以可用 then 等方法。

​ 由于 Fetch API 是基于 Promise 设计，旧浏览器不支持 Promise，需要使用 polyfill es6-promise

​ **大多数情况下**，实现 fetch 的 polyfill 需要涉及到的：

- promise 的 polyfill，例如 es6-promise，babel-polyfill 提供的 promise 实现
- fetch 的 polyfill 实现，例如 isomorphic-fetch 和 whatwg-fetch。

```javascript
fetch(url, options).then(
  function (response) {
    // handle HTTP response
  },
  function (error) {
    // handle network error
  }
)
```

##### 状态码之 200 和 304

​ 当客户第一次请求服务器资源，服务器成功返回资源，这时状态码为 200。每个资源请求完成后，通常会被缓存在客户端，并会记录资源的有效时间和修改时间。当客户再次请求该资源，客户端首先从缓存中查找该资源。如果该资源存在，并且在有效期，则不请求服务器，直接在缓存中读取。如果不在有效期，客户端会请求服务器，重新获取。服务器会判断修改时间，如果没有修改过，就会返回状态码 304，告诉客户端该资源仍然有效，客户端会直接使用缓存的资源。

##### 如何设置浏览器不缓存

```
response.setHeader("Cache-Control","no-cache");
response.setHeader("Pragma","no-cache");
response.setDateHeader("Expires",0);
```

##### 箭头函数可以 new 吗

​ 箭头函数、没有 prototype、没有自己的 this 指向、不可以使用 arguments、自然不可以 new。

##### 移动端兼容问题

- 移动端 click 300ms 延时响应：使用 FastClick
- css 动画页面闪白，动画卡顿：1.尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用 position 的 left 和 top 来定位 2.开启硬件加速

##### v-for 和 v-if 可以一起使用吗

​ 当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中，所以，不推荐 v-if 和 v-for 同时使用。

​ 解决办法：可以将 `v-if` 置于外层元素或<template>上。

##### v-show 和 v-if 的区别

- v-if 是真正的条件渲染，只有当条件第一次变为真的时候才会开始渲染条件块。
- v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
- 一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

##### es6 的兼容方法

- Babel

  babel 将 ES6（以及以上版本）中的语法转换为 ES5 形式

- babel-polyfill

  以上的 babel 只能转换 ES6 中的新语法，并不能转换新的 API，要想使用新版的 API，还要进行 polyfill（也称为 shim）这种模式的转换。在可能的情况下，polyfill 会为新环境中的行为定义在旧环境中的等价行为

##### 数组和链表的区别

- 数组

  数组是将元素在内存中连续存放，由于每个元素占用内存 相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其 中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。

- 链表

  链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后 一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元 素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。

##### flex 的三个属性

​ flex ==> flex-grow flex-shrink flex-basic

- flex-grow 当还有剩余空间时，为有该属性子元素按比例分配剩余空间。默认：0.

- flex-shrink 当子元素的宽度超出父元素时，包含该属性的子元素按比例减去超出的宽度。默认：1.

- flex-basic 指定元素的宽度，优先级高于 width

##### 数组和类数组的区别

​ 类数组的定义：

- 拥有 length 属性，其它属性（索引）为非负整数

- 不具有数组所具有的方法；

  javascript 中常见的类数组有 `arguments`对象和 DOM 方法的返回结果。比如 `document.getElementsByTagName()`。

  类数组转换为数组的方法：

  - Array.prototype.slice.call(arrayLike)
  - Array.from(arrayLike)
  - ...扩展运算符: [...arguments]

##### 手写 promise(promise 原理)

​ 在 Promise 的内部，有一个状态管理器的存在，有三种状态：pending、fulfilled、rejected。　　　　
​ (1) promise 对象初始化状态为 pending。　　　　
​ (2) 当调用 resolve(成功)，会由 pending => fulfilled。　　　　
​ (3) 当调用 reject(失败)，会由 pending => rejected。　　
​ 需要记住的是注意 promsie 状态 只能由 pending => fulfilled/rejected, 一旦修改就不能再变。

```javascript
class myPromise {
  constructor(process) {
    this.status = "pending"
    this.msg = ""
    process(this.resolve.bind(this), this.reject.bind(this))
    return this
  }
  resolve(val) {
    this.status = "fulfilled"
    this.msg = val
  }
  reject(err) {
    this.status = "rejected"
    this.msg = err
  }
  then(resolve, reject) {
    if (this.status == "fulfilled") {
      resolve(this.msg)
    }
    if (this.status == "rejected") {
      reject(this.msg)
    }
  }
}
var result = new myPromise((resolve, reject) => {
  resolve("OK")
})
result.then(
  (res) => {
    console.log("success: ${res}")
  },
  (err) => {
    console.log("failed: ${err}")
  }
)
```

##### promise 实现 sleep

```javascript
function sleep(time) {
  return new Promise((resolve) => setTimeout(resolve, time))
}
sleep(3000).then(() => {
  console.log("sleep 3s")
})
```

##### 实现 reduce 方法

```javascript
Array.prototype.myreduce = function (callback, initValue) {
  let total = initValue ? initValue : this[0]
  for (let i = initValue ? 0 : 1; i < this.length; i++) {
    total = callback(total, this[i], i, this)
  }
  return total
}
let arr = [1, 2, 3, 4]
console.log(
  arr.myreduce((pre, cur) => {
    return pre + cur
  }, 10)
)
```

##### 实现 map 方法

```javascript
//1
function map(arr, callback) {
  if (!Array.isArray(arr) || !arr.length || typeof callback !== "function") {
    return []
  } else {
    let res = []
    for (let i = 0; i < arr.length; i++) {
      res.push(callback(arr[i], i, arr))
    }
    return res
  }
}
var result = map([1, 2, 3], (item) => {
  return item * item
})
console.log(result)
//2
Array.prototype.mymap = function (callback) {
  return this.reduce((pre, cur) => {
    return pre.concat(callback(cur))
  }, [])
}
let arr = [1, 2, 3]
console.log(arr.mymap((item) => item * item))
//3
Array.prototype.mymap = function (callback) {
  let newArr = []
  for (let item of this) {
    newArr.push(callback(item))
  }
  return newArr
}
```

##### js 数组遍历方法

- for 循环
- forEach
- map
- for...in
- for...of

##### map 和 forEach 的区别

​ forEach()的返回值是 undefined，不可以链式调用。

​ map()返回一个新数组，原数组不会改变。

​ 没有办法终止或者跳出 forEach()循环，除非抛出异常。

```javascript
let arr = [1, 2, 3, 4, 5]
var res = arr.forEach((num, index) => {
  return (arr[index] = num * 2)
})
console.log(arr) //[2, 4, 6, 8, 10]
console.log(res) //undefined

let res = arr.map((num) => {
  return num * 2
})
console.log(arr) //[1, 2, 3, 4, 5]
console.log(res) //[2, 4, 6, 8, 10]
```

##### js 实现数组 map 方法

```javascript
Array.prototype.newMap = function (fn) {
  let arr = this
  if (!Array.isArray(arr) || !arr.length || typeof fn !== "function") {
    return []
  } else {
    let newArr = []
    for (let i = 0; i < arr.length; i++) {
      newArr.push(fn(arr[i], i, arr))
    }
  }
  return newArr
}
```

##### 让一个元素消失的方法 visibility:hidden,opacity:0,display:none

- opacity:0

  该元素隐藏起来了，但是依然占据空间的位置，不会改变页面布局，并且依然能触发该元素已经绑定的事件，会引起重绘。

- visibility:hidden

  该元素隐藏起来了，但是依然占据空间的位置，不会改变页面布局，但是不会触发该元素已经绑定的事件，会引起重绘。

- display:none

  该元素隐藏起来了，并且占据的空间消失，改变页面布局，会引起重排和重绘。

##### 双边距重叠问题（外边距折叠）

​ 多个相邻（兄弟或者父子关系）普通流的块元素垂直方向 marigin 会重叠

​ 折叠的结果为：

​ 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
​ 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
​ 两个外边距一正一负时，折叠结果是两者的相加的和。

##### 清除浮动

- 父级添加 overflow: hidden；子元素浮动了，会造成父元素的高度坍塌。只要给父元素添加 overflow: hidden;属性，就可以解决浮动带来的影响。

  ```javascript
  <ul class="cc">
      <li></li>
      <li></li>
  </ul>
  <style type="text/css">
      li {
          list-style: none;
          height: 100px;
          width: 100px;
          float: left;
          background: red;
          margin-left: 20px;
      }

      ul {
          overflow: hidden;
          padding: 0;
          margin: 0;
          background: pink;
      }
  </style>
  ```

- 通过属性 clear:both;达到清除浮动的目的;元素浮动后，只需要在浮动元素添加多一个块级元素，并添加 clear: both;属性，便可以达到清除浮动的目的。

  ```javascript
  <style type="text/css">
      li {
          list-style: none;
          height: 100px;
          width: 100px;
          float: left;
          background: red;
          margin-left: 20px;
      }
      ul{
          background: pink;
      }
  </style>
  <ul class="cc">
      <li></li>
      <li></li>
      <div style="clear: both;"></div>
  </ul>
  ```

- 通过给父级元素添加伪类 after，达到清除浮动的目的；这种方式也是使用 clear: both;的方式达到效果，只是变相的使用了伪类 after，使得页面结构更简洁，也是常用的清理浮动的方式。

  ```javascript
  <style type="text/css">
      li {
          list-style: none;
          height: 100px;
          width: 100px;
          float: left;
          background: red;
          margin-left: 20px;
      }

      .cc:after {
          content: '';
          height: 0;
          line-height: 0;
          display: block;
          visibility: hidden;
          clear: both;
      }
      ul{
          background: pink;
      }
  </style>
  <ul class="cc">
      <li></li>
      <li></li>
  </ul>
  ```

- 使用双伪类；此方式和上面原理一样，代码更简洁。

  ```javascript
  <style type="text/css">
      li {
          list-style: none;
          height: 100px;
          width: 100px;
          float: left;
          background: red;
          margin-left: 20px;
      }

      .cc:after,
      .cc:before {
          content: "";
          display: block;
          clear: both;
      }

      ul {
          background: pink;
      }
  </style>
  <ul class="cc">
      <li></li>
      <li></li>
  </ul>
  ```

##### css3 新特性

- background-image, background-origin, background-size, background-repeat
- boder-radius, boder-image
- box-shadow
- 媒体查询：监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式
- 过渡 transition，动画 animation，形状转换 transform

##### css 选择器有哪些，优先级呢

​ id 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器等

​ 同一元素引用了多个样式时，排在后面的样式属性的优先级高；

​ 样式选择器的类型不同时，优先级顺序为：id 选择器 > class 选择器 > 标签选择器；

​ 标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低；

​ 带有!important 标记的样式属性的优先级最高；

​ 样式表的来源不同时，优先级顺序为：内联样式> 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式

##### es6 有哪些新特性

- 新增 let、const 声明变量，实现了块级作用域
- 新增箭头函数
- 引入 promise、await/async 解决异步回调问题
- 引入 class 作为对象的模板，实现更好的面向对象编程
- 引入模块方便模块化编程
- 引入新的数据类型 symbol，新的数据结构 set 和 map

##### css 动画如何实现

​ 创建动画序列，需要使用 animation 属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes 规则实现。

​ transition 也可实现动画。transition 强调过渡，元素的一个或多个属性发生变化时产生的过渡效果。

##### float 的元素，display 是什么

​ 无论行内元素还是块元素，只要设置了 position: absolute 或者 float，display 属性值都变为 block。

##### css3 中对溢出的处理

​ text-overflow 属性，值为 clip 是修剪文本；ellipsis 为显示省略符号来表被修剪的文本；string 为使用给定的字符串来代表被修剪的文本。

​ overflow-x 主要是用来定义对水平方向内容溢出的剪切，而 overflow-y 主要是用来定义垂直方向的内容溢出的剪切。

​ overflow-x/overflow-y:visible | hidden | scroll | auto | no-display | no-content

​ visible:默认值。表示不剪切容器中的任何内容，不添加滚动条，元素将被剪切为包含对象的窗口大小，而且 clip 属性将失效

​ auto：在需要时剪切内容并添加滚动条，

​ hidden：内容溢出容器时，所有内容都将隐藏，而且不显示滚动条

​ scroll：不管内容有没有溢出容器，overflow-x 都会显示横向滚动条，overflow-y 都会显示纵向滚动条

​ no-display：当内容溢出容器时不显示内容，此时类似于添加了 display：none、

​ no-content：当内容溢出容器时不显示内容，类似于添加了 visibility：hidden；

##### 三栏布局的实现方式

```javascript
//flex布局
//优点：简单快捷
//缺点：不支持IE10以下
<template>
    <div class="box">
        <div class="left">1</div>
        <div class="content">2</div>
        <div class="right">3</div>
    </div>
</template>
<style type="text/css">
    * {
        margin: 0px;
        padding: 0px;
        box-sizing: border-box;
    }
    .box {
        display: flex;
        width: 100%;
    }
    .box > div {
        min-height: 100px;
    }
    .left {
        width: 100px;
        background: red;
    }
    .content {
        flex: 1;
        background: yellow;
    }
    .right {
        width: 100px;
        background: blue;
    }
</style>

```

```javascript
//定位布局
//优点：很快捷，设置很方便，而且也不容易出问题
//缺点：绝对定位是脱离文档流的，意味着下面的所有子元素也会脱离文档流，这就导致了这种方法的有效性和可使用性是比较差的。
<template>
    <div class="box">
        <div class="left">1</div>
        <div class="content">2</div>
        <div class="right">3</div>
    </div>
</template>
<style type="text/css">
    * {
        margin: 0px;
        padding: 0px;
        box-sizing: border-box;
    }
    .box {
        position: relative;
        width: 100%;
    }
    .box > div {
        min-height: 100px;
        position: absolute;
    }
    .left {
        left: 0px;
        width: 100px;
        background: red;
    }
    .content {
        left: 100px;
        right: 100px;
        background: yellow;
    }
    .right {
        right: 0px;
        width: 100px;
        background: blue;
    }
</style>
```

```javascript
//浮动布局
//优点：比较简单，兼容性也比较好。只要清除浮动做的好，是没有什么问题的
//缺点：浮动元素是脱离文档流，如果父元素不设置高度或者不清除浮动的话，会引起高度塌陷等问题
<template>
    <div class="box">
        <div class="left">1</div>
        <div class="right">3</div>
        <div class="content">2</div>
    </div>
</template>
<style type="text/css">
    * {
        margin: 0px;
        padding: 0px;
        box-sizing: border-box;
    }
    .box > div {
        min-height: 100px;
    }
    .left {
        float: left;
        width: 100px;
        background: red;
    }
    .content {
        background: yellow;
    }
    .right {
        float: right;
        width: 100px;
        background: blue;
    }
</style>

```

```javascript
//table布局
//优点：实现简单，代码少
//缺点：当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，而有时候这种效果不是我们想要的。
<template>
    <div class="box">
        <div class="left">1</div>
        <div class="content">2</div>
        <div class="right">3</div>
    </div>
</template>
<style type="text/css">
    * {
        margin: 0px;
        padding: 0px;
        box-sizing: border-box;
    }
    .box {
        display: table;
        width: 100%;
    }
    .box > div {
        min-height: 100px;
    }
    .left {
        display: table-cell;
        width: 100px;
        background: red;
    }
    .content {
        display: table-cell;
        background: yellow;
    }
    .right {
        display: table-cell;
        width: 100px;
        background: blue;
    }
</style>

```

##### calc 属性

​ calc 用户动态计算长度值，任何长度值都可以使用 calc()函数计算，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；

##### z-index 的定位方法

​ z-index 属性设置元素的堆叠顺序，拥有更高堆叠顺序的元素会处于较低顺序元素之前，z-index 可以为负，且 z-index 只能在定位元素上奏效，该属性设置一个定位元素沿 z 轴的位置，如果为正数，离用户越近，为负数，离用户越远。

##### line-height 和 height 的区别

​ line-height 一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，height 一般是指容器的整体高度。

##### 属性选择器和伪类选择器的优先级

​ 属性选择器和伪类选择器优先级相同

##### 用 css 实现一个硬币旋转的效果

```javascript
<div class="coin"></div>
.coin {
  width: 100px;
  height: 100px;
  margin: 100px;
  animation: rotate 5s linear infinite;
  background-color: goldenrod;
  border-radius: 50%;
}

.coin:hover {
  animation-play-state: paused;
}

@keyframes rotate {
  0% {
    transform: rotateY(0deg);
  }

  100% {
    transform: rotateY(360deg);
  }
}
```

##### 重绘 repaint 和重排 reflow

​ 一个页面由两部分组成：

​ DOM：描述该页面的结构
​ render：描述 DOM 节点 (nodes) 在页面上如何呈现

​ 当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为重绘。

​ 如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为重排。

​ 下列情况会发生重排：

- 页面初始渲染

- 添加/删除可见 DOM 元素

- 改变元素位置

- 改变元素尺寸（宽、高、内外边距、边框等）

- 改变元素内容（文本或图片等）

- 改变窗口尺寸

  重绘发生的情况：
  重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改 DOM 元素的字体颜色（只有 Repaint，因为不需要调整布局）

  减少重绘重排的方法有：

  - 样式集中改变，可以添加一个类，样式都在类中改变
  - 将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素
  - display：none；先设置元素为 display：none；然后进行页面布局等操作；设置完成后将元素设置为 display：block；这样的话就只引发两次重绘和重排
  - 不在布局信息改变时做 DOM 查询

##### overflow 原理

​ overflow: hidden;能清除块内子元素的浮动影响. 因为该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动

##### css 画三角形

```javascript
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom: 100px solid red;
}
```

##### css 预处理器

​ less,sass,stylus

##### get 请求传参长度的误区

​ HTTP 协议 未规定 GET 和 POST 的长度限制

​ GET 的最大长度限制是因为 浏览器和 web 服务器限制了 URI 的长度

​ 不同的浏览器和 WEB 服务器，限制的最大长度不一样

​ 要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte

##### HTTP 的请求

​ HTTP 由四部分组成：

- 请求行（request line）：用于说明请求类型、要访问的资源路径、HTTP 版本号（GET /index.html HTTP/1.1）
- 请求头部（header）：用于说明服务器要使用的附加信息
- 一个空行
- 请求数据（body）：任意添加的数据

##### get 和 post 请求在缓存方面的区别

​ get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。

​ post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。

##### 闭包的概念

- 什么是闭包

  当嵌套的内部函数引用了其外部函数的变量（函数）时，就形成了闭包。

- 闭包的生命周期

  产生：嵌套的外部函数被调用的时候，也就是执行嵌套的内部函数的定义时。

  死亡：在嵌套的内部函数成为垃圾对象时(f=null)

- 常见的闭包

  1.将嵌套的内部函数作为其外部函数的返回值；

  ```javascript
  function fn() {
    var a = 1
    function foo() {
      //闭包
      a++
      console.log(a)
    }
    return foo
  }

  var fun = fn()
  fun() //2
  fun() //3
  ```

  2.将函数作为另一个函数的实参被调用时。

  ```javascript
  function foo(msg, time) {
    setTimeout(function () {
      console.log(msg) //'yy'
    }, time)
  }
  foo("yy", 2000)
  ```

- 闭包的作用

  （1）延长局部变量的生命周期；

  （2）在函数外部可以访问到函数内部的变量。

- 闭包的缺点

  由于闭包使得局部变量的生命周期得以延长，而未及时释放其所占的内存，积累多了就会引起内存泄漏问题。

- 解决办法

  （1）能不用闭包就不用闭包

  （2）及时释放

##### 如何解决异步回调地狱

​ promise, generator, async/await

##### 作用域链

​ 多个上下级关系的作用域形成的链就是作用域链，它的方向是从内到外的，查找变量时就是沿着作用域链来查找的，先在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则在上一级作用域的执行上下文中查找对应的属性，如果有则返回，如果没有则继续往上级作用域查找，直到全局作用域，如果还找不到就抛出找不到的异常。

##### 为什么 js 是单线程

​ JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程。

​ 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

##### 任务队列和事件循环

​ js 中的异步操作比如 fetch setTimeout setInterval 压入到调用栈中的时候里面的回调函数会进入到消息队列中去，消息队列会等到调用栈清空之后再执行

​ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

​ 所有任务可以分成两种，一种是 **同步任务** （synchronous），另一种是 **异步任务** （asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有等主线程任务执行完毕，"任务队列"开始通知主线程，请求执行任务，该任务才会进入主线程执行。

​ "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。

​ 具体来说，异步执行的运行机制如下:（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）

```text
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，将可运行的异步任务添加到执行栈中，开始执行。
（4）主线程不断重复上面的第三步
```

​ 只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。这个过程会不断重复。

​ 整个这种运行机制又称为 Event Loop（事件循环）

##### EventLoop 事件循环

​ 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

1. 整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；
2. 同步任务会直接进入主线程依次执行；
3. 异步任务会再分为宏任务和微任务；
4. 宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中；
5. 微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中；
6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；
7. 上述过程会不断重复，这就是 Event Loop 事件循环；

##### 定时器 setTimeout 倒计时为什么会有误差

​ "任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做"定时器"（timer）功能，也就是定时执行的代码。定时器功能主要由 setTimeout()和 setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。

​ 需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。

##### 哪些是异步任务

- setTimeout 和 setInterval
- DOM 事件
- Promise
- 网络请求
- I/O

##### 宏任务和微任务

​ macrotask 和 microtask 表示异步任务的两种分类。

​ promise async await 的异步操作的时候会加入到微任务中去，会在调用栈清空的时候立即执行，调用栈中加入的微任务会立马执行

- 宏任务

  macrotask，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

  宏任务包括：

  - script（整体代码）
  - setTimeout
  - setInterval
  - setImmediate(node.js 环境)

- 微任务

  microtask,可以理解是在当前 task 执行结束后立即执行的任务。

  微任务包括：

  - Promise.then
  - Object.observe
  - MutationObserver
  - process.nextTick(node.js 环境)

  执行优先级 调用栈>微任务队列>消息队列

##### 原型

- 每个函数都有一个 prototype 属性，它默认指向一个 Object 空对象，即原型对象。

- 原型对象中有一个属性 constructor，它指向函数对象本身

  构造函数.prototype.constructor === 构造函数

- 给原型对象添加属性方法，则函数所有的实例对象自动拥有原型中的属性方法

- 对象的隐式原型的值为其对应的构造函数的显式原型的值

  构造函数.prototype === 实例对象.**proto**

- 函数的显式原型指向的对象默认是空 Object 实例对象（但 Object 函数不满足，因为它的**proto**为 null）

  console.log(Function.prototype instanceof Object) //true

  console.log(fn.prototype instanceof Object) //true

  console.log(Object.prototype instanceof Object) //false

- Object 的原型对象是原型链尽头

  console.log(Object.prototype.**proto**) //null

- 所有函数都是 Function 的实例对象（包括 Function 本身)，就是所有函数都是 new Function 创建出来的

  function foo() { }

  var foo = new Function()

  Function = new Function()

  Object = new Function()

- （隐式）原型链：查找对象的属性方法

  访问一个对象的属性方法时，先在自身中查找，查到返回，如果没有，再沿着**proto**这条链向上查找，找到返回。如果最终没有找到，则返回 undefined。

- instanceof 原理

  instanceof 用于判断一个引用类型是否属于某个构造函数

  A（实例对象）instanceof B（构造函数）

  如果 B 构造函数的 prototype 属性指向的原型对象在 A 实例对象的原型链上，返回 true，否则返回 false

##### 对象的创建模式

​ 1.es5 中类的创建方法：

- Object 构造函数模式

  先创建空 Object 对象，再动态添加属性方法

  ```javascript
  var p = new Object()
  p.age = 12
  p.setName = function (name) {
    this.name = name
  }
  ```

- 对象字面量模式

  使用{ }创建对象，同时指定属性方法

  ```javascipt
  var p = {name: 'tom', age: 12, setName: funtion(){}}
  ```

- 工厂模式

  通过工厂函数动态创建对象并返回。返回一个对象的函数就是工厂函数

  ```javascript
  funtion createPerson(name, age){
  	var obj = {name: name, age: age, setName: funtion(){}}
  	return obj
  }
  var p = createPerson('tom', 12)
  ```

- 自定义构造函数模式

  自定义构造函数，通过 new 创建对象

  采用 new 之后 this 才会指向实例对象，构造函数里面不需要 return

  通过 this 创建的叫做实例成员，只有实例才能访问

  不通过 this 创建的叫做静态成员，可以通过构造函数名直接访问，不能通过实例去访问

  ```javascript
  funtion Person(name, age){
  	this.name = name
  	this.age = age
      this.setName = function(name){
          this.name = name
      }
  }
  person.sex = 'male' //静态成员
  var p = new Person('tom', 12)
  ```

- 构造函数+原型的组合模式

  自定义构造函数，属性在函数中初始化，方法添加到原型中

  ```javascipt
  funtion Person(name, age){
  	this.name = name
  	this.age = age
  }
  Person.prototype.setName = function(name){this.name = name}
  var p = new Person('tom', 12)
  ```

  2.es6 中类的创建方法：

```javascript
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  sayName() {
    return this.name + this.age
  }
}
var student = new Person("zhm", 18)
```

##### 继承

- 原型链继承

  既继承了父类的模板，又继承了父类的原型对象，**所有的子类的实例都会共享父类的实例属性（引用类型的）**。在创建子类型的实例时，没有办法在不影响所有实例的情况下，向父类型的构造函数传递参数

  - 问题 1：原型中包含的引用类型属性将被所有实例共享；
  - 问题 2：子类在实例化的时候不能给父类构造函数传参；

  ```javascript
  //定义父类型构造函数
  function Supper(){
  	this.supProp = 'Supper'
  }
  //给父类型的原型添加方法
  Supper.prototype.showSup = funtion(){ }
  //定义子类型的构造函数
  function Sub(){
  	this.subProp = 'Sub'
  }
  //创建父类型的实例对象赋值给子类型的原型
  Sub.prototype = new Supper()
  //将子类型原型的构造属性设置为子类型
  Sub.prototype.constructor = Sub
  //给子类型原型添加方法
  Sub.prototype.showSub = funtion(){}
  //创建子类型对象，可以调用父类型的方法
  var sub = new Sub()
  sub.showSup()
  ```

  ```javascript
  // 父类
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  // 父类的原型对象属性
  Person.prototype.id = 10
  // 子类
  function Boy(sex) {
    this.sex = sex
  }
  // 创建父类型的实例对象赋值给子类型的原型
  Boy.prototype = new Person("c5", 27)
  // 将子类型原型的构造属性设置为子类型
  Boy.prototype.constructor = Boy
  var b = new Boy()
  alert(b.name) // c5
  alert(b.id) //10
  ```

- 借用构造函数继承

  继承了父类的模板，不继承父类的原型对象。由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。

  ```javascript
  //定义父类型构造函数
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  //定义子类型的构造函数，在子类型构造函数中调用父类型构造
  //关键：call()
  function Student(name, age, price) {
    Person.call(this, name, age)
    this.price = price
  }
  var s = new Student("tom", 20, 1000)
  ```

  ```javascript
  // 父类
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  // 父类的原型对象属性
  Person.prototype.id = 10
  // 子类
  function Boy(name, age, sex) {
    //call实现继承
    Person.call(this, name, age)
    this.sex = sex
  }
  var b = new Boy("c5", 27, "男")
  alert(b.name) // c5
  alert(b.id) //undefined,父类的原型对象并没有继承
  ```

- 原型链+借用构造函数的组合继承

  利用原型链实现对父类型对象的方法继承，利用 call 方法借用父类型构造函数初始化相同属性

  既继承了父类的模板，又继承了父类的原型对象

  缺点：每一次创建子类实例对象的时候都要 new 一个父类的实例对象

  ```javascript
  // 父类
  function Person(name, age) {
    this.name = name
    this.age = age
  }
  // 父类的原型对象属性
  Person.prototype.id = 10
  // 子类
  function Boy(name, age, sex) {
    //call实现继承
    Person.call(this, name, age)
    this.sex = sex
  }
  // 创建父类型的实例对象赋值给子类型的原型
  Boy.prototype = new Person()
  // 将子类型原型的构造属性设置为子类型
  Boy.prototype.constructor = Boy
  var b = new Boy("c5", 27, "男")
  alert(b.name) // c5
  alert(b.id) //10
  ```

- 寄生式组合继承

  Boy.prototype 上加东西会影响 Person.prototype

  ```javascript
  //Boy.prototype = new Person()
  Boy.prototype = Person.prototype
  //解决方案，浅拷贝
  Boy.prototype = Object.create(Person.prototype)
  ```

- class 实现继承

  ```javascript
  class Animal {
    constructor(name) {
      this.name = name
    }
    getName() {
      return this.name
    }
  }
  class Dog extends Animal {
    constructor(name, age) {
      super(name)
      this.age = age
    }
  }
  ```

##### 对象字面量代替 switch 方法

```javascript
const fruitsColor = {
  red: ["apple"],
  yellow: ["banana"],
}
function printFruits(color) {
  return fruitsColor[color] || []
}
console.log(printFruits("y"))
```

##### 前端中的事件流

​ 事件流描述的是从页面中接收事件的顺序

​ 事件捕获：当某个元素触发某个事件（如 onclick），顶层对象 document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。

​ 事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。

​ 事件冒泡：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被依次触发。

​ 事件流的 3 个阶段：

- 事件捕获阶段（事件从 Document 节点 自上而下 向目标节点传播的阶段）

  捕获的流程为：window -> document -> html -> body -> ... -> 目标元素。

- 处于目标阶段（真正的目标节点正在处理事件的阶段）

- 事件冒泡阶段（事件从目标节点 自下而上 向 Document 节点传播的阶段）

  冒泡的流程为：目标元素 -> ... -> body -> html -> document -> window。

  阻止事件的默认行为

- return false

- w3c：event.preventDefault()

- IE：event.returnValue = false

  阻止事件冒泡

- return false

- w3c：event.stopPropagation()

- ie：event.cancelBubble = true

  阻止事件捕获

- event.stopPropagation()

- event.stopImmediatePropagation()

- 两者的区别：前者只会阻止冒泡或者是捕获。 但是后者除此之外还会阻止该元素的其他事件发生，但是前者就不会阻止其他事件的发生。

  阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他的两个事件将不会被执行。

- event.stopImmediatePropagation()

##### 事件模型

- 原始事件模型（DOM0 级）
- DOM2 事件模型
- IE 事件模型

##### 事件级别

​ 三个事件级别，注意没有 DOM1，因为 DOM1 标准制定的时候没有涉及 DOM 事件。

- DOM0：element.onclick = function(){}

  `DOM0` 级处理事件就是将一个函数赋值给一个事件处理属性。

  DOM0 级事件处理程序的缺点在于一个处理程序无法同时绑定多个处理函数

- DOM2：element.addEventListener('click', function(){}, false)

  DOM2 级事件在 DOM0 级事件的基础，弥补 DOM0 级事件无法同时绑定多个处理函数的缺点，它允许给一个事件添加多个处理函数。

  DOM2 级事件定义了 `addEventListener` 和 `removeEventListener` 两个方法，分别用来绑定和解绑事件

- DOM3：element.addEventListener('keyup', function(){}, false)

  `DOM3` 级事件在 `DOM2` 级事件的基础上添加了更多的事件类型

##### 事件委托

​ 事件委托就是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件委托的原理是 DOM 元素的事件冒泡。

##### this, call, apply, bind

​ 总结：call 和 apply 会立即执行，而 bind 不会立即执行，bind 除了返回是函数以外，它的参数和 call 是一样的。call 传参是以逗号分割开，而 apply 传参则是一个数组

- call 和 apply 共同点

  都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。

  调用 call 和 apply 的对象，必须是一个函数 Function

- call 和 apply，bind 的区别

  - call

    - 调用 call 的对象，必须是个函数 Function。

    - call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。

    - 第二个参数开始，可以接收任意个参数。每个参数会映射到 Function 对应的参数上。

    - call 的使用场景

      对象的继承

      借用方法

  - apply

    - 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
    - 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

  - bind

    - bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。
    - bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是， bind 方法的返回值是函数，并且需要稍后调用，才会执行 。而 apply 和 call 则是立即调用。

  - 总结

    call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。

    bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

##### 图片的预加载和懒加载

​ 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

​ 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

​ 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。
​ 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

##### mouseover 和 mouseenter 的区别

​ mouseover 经过自身盒子触发，经过子盒子也触发，拥有冒泡特性，对应的移出事件是 mouseout

​ mouseenter 只经过自身盒子触发，没有冒泡特性，对应的移出事件是 mouseleave

##### js 的 new 操作符做了哪些事情

​ new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。

##### 改变函数内部 this 指针的指向函数（bind, apply, call）

​ 通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象；第二个是要传入的参数，apply 是数组，而 call 是 arg1，arg2...这种形式。

​ 通过 bind 改变 this 作用域会返回一个新的函数，这个函数不会马上执行。

##### js 的各种位置，比如 clientHeight, scrollHeight, offsetHeight, clientTop, scrollTop 的区别

​ clientHeight：表示的是可视区域的高度，不包含 border 和滚动条

​ offsetHeight：表示可视区域的高度，包含了 border 和滚动条

​ scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。

​ clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0

​ scrollTop： 代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度

​ offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。

##### js 垃圾回收机制

​ JS 的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。

​ 变量的生命周期：当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS 有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。

​ js 垃圾回收方式：JS 执行环境中的垃圾回收器怎样才能检测哪块内存可以被回收有两种方式：标记清除（mark and sweep）、引用计数(reference counting)。

##### 内存溢出和内存泄漏

- 内存溢出

  一种程序运行出现的错误

  当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误。

- 内存泄漏

  占用的内存没有及时释放

  内存泄漏多了就容易导致内存溢出

- 常见的内存泄漏

  意外的全局变量

  没有及时清理计时器或回调函数

  闭包

  脱离 dom 的引用（比如 var div=document.querySelector('div')之后将其删除，但是并未对消除 div 这个引用，在内存中依然保留了对于 div 的引用）

##### 手写 Promise

```javascript
class mPromise {
  constructor(process) {
    this.status = "pending"
    this.msg = ""
    process(this.resolve.bind(this), this.reject.bind(this))
    return this
  }
  resolve(val) {
    this.status = "fulfilled"
    this.msg = val
  }
  reject(err) {
    this.status = "rejected"
    this.msg = err
  }
  then(resolve, reject) {
    if ((this.status = "fulfilled")) {
      resolve(this.msg)
    }
    if ((this.status = "rejected")) {
      reject(this.msg)
    }
  }
}
var myPromise = new mPromise((resolvev, reject) => {
  resolve("OK")
})
myPromise.then(
  (val) => {
    console.log(`success: ${val}`)
  },
  (err) => {
    console.log(`failed: ${err}`)
  }
)
```

##### Promise 实现 sleep

```javascript
function mysleep(time) {
  return new Promise((resolve) => setTimeout(resolve, time))
}
```

##### eval 是做什么的

​ 它的功能是将对应的字符串解析成 js 代码并运行，并返回执行的结果。

​ 应该避免使用 eval，因为非常消耗性能（2 次，一次解析成 js，一次执行）

​ 由 json 字符串转换为 json 对象的时候可以用 eval

##### 如何理解前端模块化

​ 前端模块化就是将复杂的文件编程一个一个独立的模块，比如 js 文件等等

​ 分成独立的模块的好处：避免命名冲突；更好的分离，按需加载；更高复用性；高可维护性

​ 这样会引来模块之间相互依赖的问题，所以有了 commonJS 规范，AMD，CMD 规范等等，以及用于 js 打包（编译等处理）的工具 webpack

##### Commonjs, AMD, CMD

- Commonjs: 每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载 require()引入模块。
- AMD: 它是一个在浏览器端模块化开发的规范，由于不是 JavaScript 原生支持，使用 AMD 规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎 RequireJS
- CMD: CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样

##### js 判断类型

- typeof

  typeof 可以识别出基本类型 boolean,number,undefined,string,symbol。但是不能识别 null，null 会返回 object 类型。对于引用类型，会把 array、object 统一归为 object 类型,但是可以识别出 function。

- instanceof

  从结果中看出 instanceof 不能识别出基本的数据类型 number、boolean、string、undefined、null、symbol。但是可以检测出引用类型，如 array、object、function。

- Object.prototype.toString.call

  此方法可以相对较全的判断 js 的数据类型。

##### 数组常用方法

​ push, pop, shift, unshift, splice, sort, reverse, map, filter, reduce

##### 数组去重

```javascript
//利用es6中的Set方法去重
let arr = [1, 0, 0, 2, 9, 8, 3, 1]
arr1 = [...new Set(arr)]
```

```javascript
//利用数组的indexOf方法去重
let arr = [1, 0, 0, 2, 9, 8, 3, 1]
function unique(arr) {
  var arr1 = []
  for (var i = 0; i < arr.length; i++) {
    if (arr1.indexOf(arr[i]) == -1) {
      arr1.push(arr[i])
    }
  }
  return arr1
}
console.log(unique(arr))
```

##### js 的语言特性

​ 运行在客户端浏览器上；

​ 不用预编译，直接解析执行代码；

​ 是弱类型语言，较为灵活；

​ 与操作系统无关，跨平台的语言；

​ 脚本语言、解释性语言

##### js 实现跨域

- JSONP

  通过动态创建 script，再请求一个带参网址实现跨域通信。

  jsonp 缺点：只能实现 get 一种请求。

- CORS

  跨域资源共享，服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带 cookie 请求，前后端都需要设置。

- postMessage

  window.postMessage 是一个 HTML5 的 api，可以跨域操作的 window 属性之一，允许两个窗口之间进行跨域发送消息。

- location.hash+iframe 跨域

  a 欲与 b 跨域相互通信，通过中间页 c 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。

- window.name+iframe 跨域

  通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。

- document.domain+iframe 跨域

  此方案仅限主域相同，子域不同的跨域应用场景

  两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。

- （nginx/nodejs 中间件）代理跨域

  启动一个代理服务器，实现数据的转发。

##### 常见的 content-type 的类型有哪些

​ text/plain 　　　　　　　　文本类型

​ text/css 　　　　　　　 css 类型

​ text/html 　　 　　　　　 html 类型

​ application/x-javascript 　　 js 类型

​ application/json 　　　　　 json 类型

​ image/png jpg gif 　　　　　 image/\*

##### options 请求

​ options 请求方法的主要用途有两个：

- 获取服务器支持的 http 请求方法
- 用来检查服务器的性能

##### 首屏加载优化处理

- gzip 压缩
- 开启 http2.0
- CDN 加速
- 无模块化 js 的按需加载
- 缓存

##### v-for 和 v-if 哪个优先级高

​ v-for 的优先级比 v-if 高

​ 如果两个同时出现怎么优化得到更好的性能：

​ 在外层嵌套一层 v-if 判断的 template,然后再内部进行 v-for 循环。

##### 同源策略及限制

​ 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

​ 协议、域名、端口只要有一个不一样，就是不同的源。

​ **不同源的限制**

- Cookie、LocalStorage、IndexDB 无法获取
- DOM 无法获取
- Ajax 请求不能发送(Ajax 只限于同源使用，不能跨域使用)

##### 前后端如何通信

- ajax

  ajax 的核心是 XMLHttpRequest，通过对该对象的操作来进行异步的数据请求。有同源限制。

  浏览器发起请求，服务器返回数据，服务器不能主动返回数据，要实现实时数据交互只能是 ajax 轮询（让浏览器隔个几秒就发送一次请求，然后更新客户端显示。这种方式实际上浪费了大量流量并且对服务端造成了很大压力）。

- websocket

  客户端和服务端的双向长连接通信

  websocket 是 HTML5 出的东西（协议），是一种全双工通信机制，两端可以及时地互发事件，互发数据，相互通信，只需要浏览器和服务器建立一次连接，服务器就可以主动推送数据到浏览器实现实时数据更新。

- EventSource

  就是 SSE（服务端推送）技术

  server-sent event（SSE）：只是从服务器端往客户端单向传输数据

##### 跨域的原理

​ 跨域是指从一个域名的网页去请求另一个域名的资源。但是一般情况下不能这么做，它是由浏览器的同源策略造成的，是浏览器对 js 施加的安全限制。只要 协议，域名，端口有任何一个的不同，就被当作是跨域。跨域原理，即是通过各种方式，避开浏览器的安全限制。

##### window.requestAnimationFrame()

​ **`window.requestAnimationFrame()`** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

##### CSRF

​ CSRF（Cross-site request forgery）跨站请求伪造。

​ **攻击原理**

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
4.
5. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
6. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

​ **防御措施**

- 在请求地址中添加 token 并验证（可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，缺点是难以保证 token 本身的安全）
- 验证 HTTP Referer 字段（简单易行，但 referer 可能被改变）
- 在 HTTP 头中自定义属性并验证（跟 Token 验证差不多，把 token 放到 HTTP 头中自定义的属性中）

##### XSS

​ XSS（cross-site scripting）跨域脚本攻击

​ **攻击原理**

​ 恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。

​ **防御措施**

- 对用户提交的代码进行转义
- 对于用户提交的内容，要进行过滤后再显示

##### 平时怎么调试 js 的

​ 一般用 Chrome 自带的控制台

##### es6，es7 的新语法

​ promise，await/async，let、const、块级作用域、箭头函数

##### promise 的状态有哪些

​ 等待(pending)、已完成(fulfilled)、已拒绝(rejected)

##### OSI 七层模型

​ 应用层：文件传输，常用协议 HTTP，snmp，FTP ，SMTP

​ 表示层：数据格式化，代码转换，数据加密，

​ 会话层：建立，解除会话

​ 传输层：提供端对端的接口，tcp,udp

​ 网络层：为数据报选择路由，IP，icmp

​ 数据链路层：传输有地址的帧

​ 物理层：二进制的数据形式在物理媒体上传输数据

##### TCP/IP 的体系结构

​ 应用层

​ 运输层

​ 网络层

​ 网络接口层

##### 说一下用户从输入 url 到显示页面这个过程发生了什么

- DNS 解析
- TCP 连接
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 连接结束

##### TCP 建立连接的三次握手过程

​ 第一次握手：起初客户端和服务器都处于 CLOSED 状态，在客户端打算建立 TCP 连接时，向服务器发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq=x。这时客户端进入 SYN-SENT（同步已发送）状态。

​ 第二次握手：服务器收到连接请求报文段后，如同意建立连接，则向客户端发送确认。在确认报文段中将 SYN 位和 ACK 位都置 1，确认号是 ack=x+1，同时也为自己选择一个初始序号 seq=y。此时服务器端进入 SYN-RCVD（同步收到）状态。

​ 第三次握手：客户端收到服务器的确认后，还要向服务器发送确认。确认报文段的 ACK 置 1，确认号 ack=y+1，而自己的序号 seq=x+1。此时，TCP 连接已经建立，客户端进入 ESTABLISHED 状态（已建立连接）。当服务器收到客户端的确认后，也进入 ESTABLISHED 状态，完成三次握手，之后就可以传送数据了。

##### TCP 释放连接的四次挥手

​ 第一次挥手：此时客户端和服务器都处于 ESTABLISHED 状态，客户端先向服务器发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。客户端把连接释放报文段首部的终止控制位 FIN 置 1，序号 seq=u，此时客户端进入 FIN-WAIT-1 状态。

​ 第二次挥手：服务器收到连接释放报文段后即发出确认，确认号是 ack=u+1，自己的序号是 v，然后服务器进入 CLOSE-WAIT 状态。此时 TCP 连接处于半关闭状态。客户端收到服务器的确认后，进入 FIN-WAIT-2 状态。

​ 第三次挥手：若服务器没有要向客户端发送的数据了，其应用进程就通知 TCP 释放连接，此时服务器发出的连接释放报文段必须使 FIN=1，假定服务器的序号为 w，确认号 ack=u+1，此时服务器进入 LAST-ACK 状态。

​ 第四次挥手：客户端收到服务器的连接释放报文段后，对此发出确认。在确认报文段中将 ACK 置 1，确认号 ack=w+1，自己的序号 seq=u+1，然后进入 TIME-WAIT 状态，经过时间等待计时器设置的时间 2MSL 后，客户端才进入到 CLOSED 状态，此时就结束了这次 TCP 连接。

##### ajax 返回的状态（xhr.readyState)

​ 0 － （未初始化）还没有调用 send()方法

​ 1 － （载入）已调用 send()方法，正在发送请求

​ 2 － （载入完成）send()方法执行完成，已经接收到全部响应内容

​ 3 － （交互）正在解析响应内容

​ 4 － （完成）响应内容解析完成，可以在客户端调用了

##### 写出原生 ajax

ajax 的请求过程

- 创建 XMLHttpRequest 异步对象
- 使用 open 方法与服务器建立连接
- 发送请求
- 接收返回，在回调函数中针对不同的响应状态进行处理

```javascript
funtion ajax(url){
    //1.创建ajax对象
    var xhr = new XMLHttpRequest()
    //2.连接服务器,open(方法、文件名、异步传输）
    //方法：传输方式是get方式还是post方式。
    //文件名：告诉服务器要读哪个文件
    //异步传输：1.异步：多件事一件一件的做；2.同步：多件事情一起进行
    //但是js里面的同步和异步和现实的同步异步相反。1.同步：多件事一件一件的做；2.异步：多件事情一起进行
    xhr.open('get', url, true)
    //3.发送请求
    xhr.send()
    //4.接收返回,客户端和服务器端有交互的时候会调用onreadystatechange
    xhr.onreadyStatechange = function(){
        if(xhr.readyState == 4){
            if(xhr.status == 200){
                console.log('成功'+xhr.responseText)
            }else{
                console.log('失败')
            }
        }
    }
}
//用promise封装ajax
function newAjax(url){
      return new Promise((resolve, reject)=>{
        let xhr = new XMLHttpRequest()
        xhr.open('get', url)
        xhr.send(data)
        xhr.onreadystatechange = function(){
          if(xhr.readyState == 4){
            if(xhr.status == 200){
              resolve(xhr.responseText)
            }else{
              reject('error')
            }
          }
        }
      })
}
```

##### 获取页面所有 dom 节点

```javascript
let ele = document.querySelector("html")
let map = new Map()
let nodes = []
function findAllNodes(root) {
  for (let i = 0; i < root.childNodes.length; i++) {
    let node = root.childNodes[i]
    if (node.nodeType != 3 && node.nodeName != "SCRIPT") {
      nodes.push(node)
      let count = map.get(node.nodeName) ? map.get(node.nodeName) : 0
      map.set(node.nodeName, count + 1)
      findAllNodes(node)
    }
  }
  return nodes
}
console.log(findAllNodes(ele))
console.log(map)
```

##### 实现 push 方法

```javascript
let arr = [1,2,3]
Array.prototype.mypush = function(arguments){
      for(let i=0; i<arguments.length; i++){
        this[this.length] = arguments[i]
      }
      return this.length
}
let len = arr.push(4,5,6)
console.log(arr, len)
```

##### 数组遍历

```javascript
//1
for (let i = 0; i < arr.length; i++) {}
//2
for (let i in arr) {
  arr[i] //i是索引
}
//3
for (let value of arr) {
  value //value是遍历数组的每一项的值
}
//4
arr.map((item) => {}) //返回一个新数组
//5
arr.forEach((item) => {}) //返回undefined
```

##### CDN 原理

​ CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 网络是在用户和服务器之间增加 Cache 层，主要是通过接管 DNS 实现，将用户的请求引导到 Cache 上获得源服务器的数据，从而降低网络的访问的速度。

##### js 中==和===的区别

​ js 在比较的时候如果是 == 会先做类型转换，再判断值是否相等，如果是===类型和值必须都相等。

##### 对 webpack 的看法

​ WebPack 是一个模块打包工具，它能够很好地管理、打包 Web 开发中所用到的 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack 有对应的模块加载器。webpack 模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。

​ webpack 的两大特色：

​ code splitting（可以自动完成）

​ loader 可以处理各种类型的静态文件，并且支持串联操作

##### 前端性能优化方法

- 减少操作量

  - 尽量减少 HTTP 请求

    1. 合并文件，比如把多个 CSS 文件合成一个；
    2. CSS Sprites 利用 CSS background 相关元素进行背景图绝对定位；

  - 不要在 HTML 中使用缩放图片

    缩放图片并没有减少图片的容量，只是控制了图片的大小

  - Image 压缩

    使用工具对图片进行压缩，保证质量的同时减少了图片的大小

  - 图片懒加载

  - 减少对 DOM 的操作

    减少对 DOM 的操作，减少页面的重绘

- 提前做加载操作

  - DNS 预解析

    ```javascript
    <!--在head标签中，越早越好-->
    <link rel="dns-prefetch" href="//example.com">
    ```

  - HTTP 预连接

    ```javascript
    <link rel="preconnect" href="//example.com">
    <link rel="preconnect" href="//cdn.example.com" crossorigin>
    ```

  - 预载入组件或延迟载入组件

  - 把 CSS 放到代码页上端

    CSS 放到最顶部，浏览器能够有针对性的对 HTML 页面从顶到下进行解析和渲染

  - 使用 CDN

- 提升并行加载

  切分组件到多个域 ，提升服务器的响应能力

- js 和 css 优化

  - 从页面中剥离 js 和 css

    剥离后，能够有针对性的对其进行单独的处理策略，比如压缩或者缓存策略。

  - 精简 js 与 css

    使用工具压缩 JavaScript 和 CSS 文件

  - 脚本放到 html 代码页底部

    减少对页面的阻塞

- 异步加载

  使用 Ajax 实现异步加载，例如，滚动页面加载后面的内容，这种也比较常见。

##### 提升页面性能

- 资源压缩合并，减少 HTTP 请求

- 使用 CDN

- 预解析 DNS

- 非核心代码异步加载

  ###### 异步加载

  异步加载的方式

  - 动态脚本加载
  - defer
  - async

  异步加载的区别

  - script 标签会阻塞后续文档加载，但是 script 标签有两个属性：defer 和 async，加上这两个属性之后，在 js 真正执行之前都不会阻塞 html 的加载。

  - defer 是在 HTML 解析完之后才会执行，（后续文档加载与`script`脚本加载 并行进行，文档所有元素解析完成之后、`DOMContentLoaded`事件触发执行之前执行，不会阻塞后续文档加载。）如果是多个，按照加载的顺序依次执行。 `defer` 脚本会在 `DOMContentLoaded` 和 `load` 事件之前执行。
  - async 是在脚本加载完之后立即执行，（后续文档加载与`script`脚本加载 并行进行，后续文档渲染与`script`脚本执行 并行进行，不会阻塞后续文档加载。）如果是多个，执行顺序和加载顺序无关。 `async` 会在 `load` 事件之前执行，但并不能确保与 `DOMContentLoaded` 的执行先后顺序。

- 利用浏览器缓存

  ###### 浏览器缓存

  缓存策略都是通过设置 HTTP Header 来实现的。

  缓存策略的分类：

  - 强缓存

    强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。

    1. Expires

       缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

    2. Cache-Control

       在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 `Cache-Control:max-age=300` 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。

    3. Expires 和 Cache-Control 两者区别

       其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，**两者同时存在的话，Cache-Control 优先级高于 Expires** ；

  - 协商缓存

    协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

    - 协商缓存生效，返回 304 和 Not Modified
    - 协商缓存失效，返回 200 和请求结果

    协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

    1. Last-Modified 和 If-Modified-Since

       浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200。

    2. ETag 和 If-None-Match

       Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。

    3. 两者之间对比

       首先在精确度上，Etag 要优于 Last-Modified。

       第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。

       第三在优先级上，服务器校验优先考虑 Etag

  - 缓存机制

    强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回 304，继续使用缓存。

  - from memory cache 和 from disk cache 的区别

    在 chrome 浏览器中的控制台 Network 中 size 栏通常会有三种状态

    1.from memory cache

    2.from disk cache

    3.资源本身的大小(如：1.5k)

    三种的区别：

    - **from memory cache** ：字面理解是从内存中，其实也是字面的含义，这个资源是直接从内存中拿到的，不会请求服务器一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现 from memory cache 的情况。
    - **from disk cache** ：同上类似，此资源是从磁盘当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会 from disk cache
    - **资源本身大小数值** ：当 http 状态为 200 是实实在在从浏览器获取的资源，当 http 状态为 304 时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的

##### 前端性能衡量指标

- 白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止
- 首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间
- 用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作
- 总下载时间——页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间

##### localStorage，sessionStorage， cookie 的区别

- localStorage：localStorage 的生命周期是永久的，关闭页面或浏览器之后 localStorage 中的数据也不会消失。localStorage 除非主动删除数据，否则数据永远不会消失
- sessionStorage：sessionStorage 的生命周期是仅在当前会话下有效。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage 在关闭了浏览器窗口后就会被销毁。
- cookie：cookie 生命期为只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为 4K 左右, 有个数限制（各浏览器不同），一般不能超过 20 个。缺点是不能储存大数据且不易读取

##### MVVM

​ MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式。ViewModel 层通过双向数据绑定将 View 层和 Model 层连接了起来，使得 View 层和 Model 层的同步工作完全是自动的。

​ 【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在 MVVM 的框架下视图和模型是不能直接通信的。它们通过 ViewModel 来通信，ViewModel 通常要实现一个 observer 观察者，当数据发生变化，ViewModel 能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel 也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且 MVVM 中的 View 和 ViewModel 可以互相通信。

##### mvvm 和 mvc 模型的区别

- mvvm 各部分的通信是双向的，而 mvc 各部分通信是单向的；
- mvvm 是真正将页面与数据逻辑分离放到 js 里去实现，而 mvc 里面未分离。

##### mvvm 的实现

- **发布者-订阅者模式:** 一般通过 sub, pub 的方式实现数据和视图的绑定监听，更新数据方式通常做法是 `vm.set('property', value)`。
- **数据劫持:** vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

##### 什么是 SPA 单页面，优缺点是什么

​ **SPA**（ single-page application ），即一个 web 项目就只有一个页面（即一个 HTML 文件,HTML 内容的变换是利用路由机制实现的。

​ 仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 html 内容的变换，UI 与用户的交互，避免页面的重新加载。

​ 优点：

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
- SPA 相对对服务器压力小
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理

​ 缺点：

- 初次加载耗时多：为实现单页 web 应用功能及显示效果，需要在加载页面的时候将 js，css 统一加载，部分页面按需加载。
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

##### http2 特性

- 二进制分帧

  HTTP/2 将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装

- 多路复用

  同域名下所有通信都在单个连接上完成；单个连接可以承载任意数量的双向数据流；

- 头部压缩

  HTTP/2 使用 encoder 来减少需要传输的 header 大小。

- 服务端推送

  服务端可以在发送页面 HTML 时主动向客户端推送其它资源，而无需等到客户端浏览器解析到相应位置重新发起请求再响应。

##### 前端代码错误

- 前端错误分类

  - 代码错误

    代码错误的捕获方式

    - try...catch
    - window.onerror

  - 资源加载错误

    资源加载错误捕获

    - object.onerror
    - performance.getEntries
    - Error 事件捕获

##### Doctype 作用？严格模式与混杂模式有什么区别？他们有何意义？

​ DOCTYPE 声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。<!DOCTYPE>声明必须在 HTML 文档的第一行，这并不是一个 HTML 标签。

​ **严格模式：**又称标准模式，是指浏览器按照 W3C 标准解析代码。

​ **混杂模式：**又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。

​ 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。

- 如果文档包含严格 DTD----严格模式

- 有 URI 的过渡 DTD----严格模式；没 URI 的过渡 DTD----混杂模式

- DTD 不存在或者格式不正确----混杂模式

- HTML5 没有严格和混杂之分

- **意义：**严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。

##### 浏览器渲染过程

1. 浏览器会将 HTML 解析成一个 DOM 树
2. 将 CSS 解析成 CSS Rule Tree
3. 根据 DOM 树和 CSSOM 来构造 Rendering Tree
4. 有了 Rendering Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为布局 layout，顾名思义就是计算出每个节点在屏幕中的位置
5. 再下一步就是绘制，将 Rendering Tree 的各个节点绘制到屏幕上

##### http 状态码

- 1\*\* 信息，表示请求已接收，继续处理

- 2\*\* 成功，操作被成功接收并处理

- 3\*\* 重定向，需要进一步的操作以完成请求

- 4\*\* 客户端错误，请求包含语法错误或无法完成请求

- 5\*\* 服务器错误，服务器在处理请求的过程中发生了错误

  常见的 HTTP 状态码：

  - 200 OK- 客户端请求成功
  - 301 - 资源（网页等）被永久转移到其它 URL
  - 400 Bad Request - 客户端请求有语法错误，不能被服务器所理解
  - 401 Unauthorized - 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。
  - 403 Forbidden - 服务器收到请求，但是拒绝提供服务
  - 404 Not Found - 请求的资源（网页等）不存在
  - 500 Internal Server Error - 服务器发生不可预期的错误
  - 503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

##### HTTP 协议的主要特点

​ 1.支持客户/服务器模式。

​ 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

​ 3.灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type（Content-Type 是 HTTP 包中用来表示内容类型的标识）加以标记。

​ 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

​ 5.无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

##### 讲一下 http 缓存

​ http 缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

​ 根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存) 强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。

​ 使用 http 缓存的好处：

​ 1.减少了冗余的数据传输，节省了网费。

​ 2.缓解了服务器的压力， 大大提高了网站的性能

​ 3.加快了客户端加载网页的速度

​ http 缓存方案：

​ 1.md5/hash 缓存

​ 2.CDN 缓存（CDN 边缘节点缓存数据，当浏览器请求时，CDN 将代替源站判断并处理此处请求）

##### 从输入 url 到页面渲染的过程

- 浏览器地址栏输入 url 并回车
- 浏览器查找当前 url 是否存在缓存，并比较缓存是否过期
- DNS 解析 url 对应的 IP
- 根据 IP 建立 TCP 连接（三次握手）
- 发送 http 请求
- 服务器处理请求，浏览器接收 http 响应
- 浏览器解析并渲染页面
- 关闭 TCP 连接（四次挥手）

##### promise 简介

​ `Promise`是`ES6`加入标准的一种异步编程解决方案，通常用来封装异步操作并且可以获取其成功或失败的结果。`Promise`标准的提出，解决了`JavaScript`地狱回调的问题。

​ Promise 实例具有 then 方法和 catch 方法。

​ then 用于指定成功的回调函数。promise 实例当状态改变为 fullfilled 时调用 then 方法。

​ catch 是用于指定发生错误的回调函数。promise 实例当状态改变为 rejected 或者操作失败抛出异常错误，就会被 catch 方法捕获

​ Promise 构造函数有两个变量 `resolve` 用于返回异步执行成功的函数 `reject` 用于返回异步执行失败的函数。配合 then 与 catch 一起使用

​ `Promise`对象在创建之后，并不一定会马上就有值，只是一个代理结果，它存在三种状态：

- pending: 初始状态(等待状态)，既不是成功，也不是失败状态。
- fulfilled: 意味着操作成功完成。
- rejected: 意味着操作失败完成。

##### es6 中的 Set 和 Map

​ ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

​ 包含 add，has，delete，clear，size 方法。

​ ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，其中的键名和对应的值支持所有的数据类型。

​ 包含 set，get，has，clear，size 方法。

##### 怎么理解 vue 的单向数据流

​ 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

​ 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

​ 子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

##### vue 中的虚拟 DOM 树

​ 虚拟 DOM 树本质上就是一个普通的 js 对象，它是用来描述一段 HTML 片段的

01 当页面渲染的时候 Vue 会创建一颗虚拟 DOM 树

​ 02 当页面发生改变 Vue 会再创建一颗新的虚拟 DOM 树

​ 03 diff 算法：前后两颗新旧虚拟 DOM 树进行对比，Vue 通过 diff 算法，去记录差异的地方

04 patch 算法：将有差异的地方更新到真实的 DOM 树中

​ 虚拟 DOM 树的作用：

​ vue 中的虚拟 DOM 树只会重新渲染页面修改的地方，大大减少了对真实 DOM 树的操作。

##### 谈谈 keep-alive

​ keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染

​ 特性：

- 对应两个钩子函数 activated 和 deactivated，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated
- 一般结合路由和动态组件一起使用，用于缓存组件
- 提供 inclue 和 exclude 属性，两者都支持字符串或正则表达式，include 表示只要名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 的优先级比 include 高

##### SPA 首屏加载速度慢解决办法

- 通过 gzip 压缩
- 使用路由懒加载
- 使用更轻量级的库
- 按需加载
- CDN 加速
- 图片资源的压缩，icon 资源使用雪碧图
- 缓存

##### 图片加载优化方法

- 选择合适的图片格式和压缩大图，可从根源上截图大图加载过慢的问题。
- 使用雪碧图，iconfont，base64，css 代替图片等可减少图片 http 请求，提高页面加载速度。
- 使用 CDN 图片可达到分流的效果，减少服务券压力。
- 图片懒加载，预加载，渐进式图片等可不同程度减少白屏时间，提高产品体验。

##### vue 的核心是什么

- 数据驱动

  专注于 View 层。它让开发者省去了操作 DOM 的过程，只需要改变数据。

- 组件响应原理

  数据（model）改变驱动视图（view）自动更新

- 组件化

  扩展 HTML 元素，封装可重用的代码。

##### http1.0 和 http1.1 的区别

1.1 长连接(Persistent Connection)
HTTP1.1 支持长连接和请求的流水线处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启长连接 keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。HTTP1.0 需要使用 keep-alive 参数来告知服务器端要建立一个长连接。

1.2 节约带宽
HTTP1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1 支持只发送 header 信息（不带任何 body 信息），如果服务器认为客户端有权限请求服务器，则返回 100，客户端接收到 100 才开始把请求 body 发送到服务器；如果返回 401，客户端就可以不用发送请求 body 了节约了带宽。

1.3 HOST 域
在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname），HTTP1.0 没有 host 域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都支持 host 域，且请求消息中如果没有 host 域会报告一个错误（400 Bad Request）。

1.4 缓存处理
在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

1.5 错误通知的管理
在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

##### v-model 的原理

​ v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，v-model 本质上是语法糖，会在内部为不同的输入元素使用不同的属性并抛出不同的事件。

- text 和 textarea 元素使用`value` 属性和 `input` 事件；
- checkbox 和 radio 使用 `checked` 属性和 `change` 事件；
- select 字段将 value 作为 `prop` 并将 `change` 作为事件。

##### Diff 算法本质

​ diff 算法的本质是**找出两个对象之间的差异**

​ diff 算法的核心是**子节点数组对比**，思路是通过**首尾两端对比**

​ key 的作用主要是

- 决定节点是否可以复用

- 建立 key-index 的索引，主要是替代遍历，提升性能。

##### 虚拟 DOM

​ 虚拟 dom 就是为了解决操作真实 dom 带来的性能问题而出现的

​ 虚拟 dom 就是用 js 对象模拟真实的 dom 节点，也就是将所有的更新 dom 的操作先全部反映在 js 对象上（虚拟 dom 上）

​ 操作内存中的 js 对象显然速度要快很多，等更新完成后，再将最终的 js 对象映射到真实的 dom 上，交由浏览器去绘制页面。

- 优点：

  保证性能下限，无需手动操作 dom，跨平台

- 缺点：

  无法进行极致优化

##### vue 响应式原理

​ 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter 。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

##### vue 双向绑定原理（响应式原理）

​ vue 是采用数据劫持结合发布/订阅模式的方式，对每个 vue 中的 data 中定义的属性循环使用 Object.defineProperty()实现数据劫持，来利用各个属性的 setter，getter，在数据变动时发布消息给订阅者，订阅者会触发相应的监听回调 update 方法，对视图进行更新。

​ 首先我们为每个 vue 属性用 Object.defineProperty()实现数据劫持，为每个属性分配一个订阅者集合的管理数组 dep；然后在编译的时候在该属性的数组 dep 中添加订阅者，v-model 会添加一个订阅者，{{}}也会，v-bind 也会，只要用到该属性的指令理论上都会；接着为 input 会添加监听事件，修改值就等于为该属性赋值，则会触发该属性的 set 方法，在 set 方法内通知订阅者数组 dep，订阅者数组循环调用各订阅者的 update 方法更新视图。

##### Vue 性能优化

- 源码优化
  - **代码模块化**，咱们可以把很多常用的地方封装成单独的组件，在需要用到的地方引用，而不是写过多重复的代码，每一个组件都要明确含义，复用性越高越好，可配置型越强越好，包括咱们的 css 也可以通过 less 和 sass 的自定义 css 变量来减少重复代码。
  - **for 循环设置 key 值**，在用 v-for 进行数据遍历渲染的时候，为每一项都设置唯一的 key 值，为了让 Vue 内部核心代码能更快地找到该条数据，当旧值和新值去对比的时候，可以更快的定位到 diff。
  - **Vue 路由设置成懒加载**，当首屏渲染的时候，能够加快渲染速度。
  - **更加理解 Vue 的生命周期**，不要造成内部泄漏，使用过后的全局变量在组件销毁后重新置为 null。
  - **可以使用 keep-alive**，keep-alive 是 Vue 提供的一个比较抽象的组件，用来对组件进行缓存，从而节省性能。
- 打包优化
  - **修改 vue.config.js 中的配置项**，把 productionSourceMap 设置为 false，不然最终打包过后会生成一些 map 文件；并且可以开启 gzip 压缩，使打包过后体积变小。
  - **使用 cdn 的方式外部加载一些资源**，比如 vue-router、axios 等 Vue 的周边插件，在 webpack.config.js 里面，externals 里面设置一些不必要打包的外部引用模块。然后在入门文件 index.html 里面通过 cdn 的方式去引入需要的插件。
  - **减少图片使用**，因为对于网页来说，图片会占用很大一部分体积，所以，优化图片的操作可以有效的来加快加载速度。可以用一些 css3 的效果来代替图片效果，或者使用雪碧图来减少图片的体积。
  - **按需引入**，咱们使用的一些第三方库可以通过按需引入的方式加载。避免引入不需要使用的部分，无端增加项目体积。比如在使用 element-ui 库的时候，可以只引入需要用到的组件。

##### nextTick 的原理

​ 在下次 `DOM` 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 `DOM`。nextTick 里面的代码会在 DOM 更新后执行。

##### new vue 的时候发生了什么

​ Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等，最后初始化完成检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM；

##### EventBus

​ `EventBus` 又称为事件总线。在 Vue 中可以使用 `EventBus` 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”，因此才需要更完善的 Vuex 作为状态管理中心，将通知的概念上升到共享状态层次。

```javascript
//初始化
Vue.prototype.$eventbus = new Vue()
//发送事件
$eventbus.$emit("aMsg", "来自A页面的消息")
//接收事件
$eventbus.$on("aMsg", (msg) => {
  // A发送来的消息
  this.msg = msg
})
```

##### vue 的生命周期

​ vue 实例从创建到销毁的过程就是 vue 的生命周期

- beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问 methods， data， computed 等上的方法和数据。
- created：实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event 事件回调，完成了 data 数据的初始化，el 没有。
- beforeMount：挂载开始之前被调用，实例已完成以下的配置： 编译模板，把 data 里面的数据和模板生成 html，完成了 el 和 data 初始化，注意此时还没有挂载 html 到页面上。
- mounted：挂载完成，也就是模板中的 HTML 渲染到 HTML 页面中，此时一般可以做一些 ajax 操作，mounted 只会执行一次。
- beforeUpdate：在数据更新之前被调用，发生在虚拟 DOM 重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程
- updated：更新完成后调用
- beforeDestroy：在实例销毁之前调用，实例仍然完全可用
- destroyed：在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用

  vue 生命周期的作用：生命周期中有多个事件钩子，让我们控制 vue 实例过程更加清晰

##### 第一次页面加载会触发哪几个钩子

​ 第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

##### vue2.x 组件通信有哪些方式

- 父子组件通信

  - 父传子：通过 props 传递，子传父：$emit 事件
  - 获取父子组件实例 $parent、$children;
  - 通过 Ref 获取实例的方式调用组件的属性或者方法;
  - Provide、inject 官方不推荐使用，但是写组件库时很常用

- 兄弟组件通信

  - Vuex

  - EventBus 事件总线 Vue.prototype.$bus = new Vue()

    发送事件：$bus.$emit()

    接收事件：$bus.$on()

- 跨级组件通信

  vuex,$attrs、$listeners, provide、inject

##### 什么是 SSR

​ SSR 就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工资放在服务端完成，然后再把 html 直接返回给客户端

- 服务端渲染的优点
  - 更好的 SEO
  - 更快的内容到达时间（首屏加载更快）
- 服务端渲染的缺点
  - 更多的开发条件限制
  - 更多的服务器负载

##### vue 获取数据在哪个周期函数

​ 一般 created/beforeMount/mounted 皆可

​ 如果要操作 DOM ，那肯定是 mounted 时候才能操作

##### vue 的虚拟 dom 会在生命周期的哪个阶段生成

​ beforeMount

##### vue-router 实现路由懒加载（动态加载路由）

​ 把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率。

##### vue-router 的两种模式

​ 原理：通过改变 URL，在不重新请求页面的情况下，更新页面视图。

- hash

  hash 模式是一种把前端路由的路径用#拼接在真实 URL 后面的模式。

  当#后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 hashchange 事件

  可以使用 **hashchange 事件**来监听 hash 值的变化，从而对页面进行跳转(渲染)。

  优点：

  - 只需要前端配置路由表, 不需要后端的参与
  - 兼容性好, 浏览器都能支持
  - hash 值改变不会向后端发送请求, 完全属于前端路由

  缺点：

  - hash 值前面需要加#, 不符合 url 规范,也不美观

- history

  history API 是 H5 提供的新特性，允许开发者直接更改前端路由，即更新浏览器 URL 地址而不重新发起请求。

  可以使用 **popstate 事件**来监听 url 的变化，从而对页面进行跳转(渲染)

  优点：

  - 符合 url 地址规范, 不需要#, 使用起来比较美观

  缺点：

  - 兼容性不如 hash，且需要服务端支持重定向，否则一刷新页面就 404 了
  - 兼容性比较差, 利用了 HTML5 History 对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持.

##### vue 从后端获得的数据写在 created 里比较好

- created 是发生在 mounted 之前的，template 还没有被渲染成 html，但是在这个阶段已经可以获取到 props 和 data 了，所以在这一步进行数据赋值是比较恰当的。
- mounted 就是页面已经渲染完成了，template 已经被渲染成 html，这个时候再进行数据请求，很有可能会造成页面闪屏。

##### $set 的用法

​ 受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。

​ 要处理这种情况，我们可以使用$set()方法，既可以给 data 对象新增属性,又可以触发视图更新。

​ 用法：this.$set(this.data,”key”,value’)

##### vue2 和 vue3 的区别

- vue2 和 vue3 双向数据绑定原理发生了变化

  **vue2** 的双向数据绑定是利用 ES5 的一个 API `Object.definePropert()`对数据进行劫持 结合 发布订阅模式的方式来实现的。

  **vue3** 中使用了 es6 的 `Proxy`API 对数据代理。

- 默认进行懒观察（lazy observation）

  在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。

- 更精准的变更通知

  比例来说：2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。

- 3.0 新加入 typescript 和 PWA 的支持

- vue2 和 vue3 组件发送改变

##### vue 中的 key 有什么作用

​ key 是 vue 中 vnode 的唯一标识，通过这个 key，我们的 diff 操作可以更准确更快速

##### vue-router 传参

- params
  - 只能使用 name，不能使用 path
  - 参数不会显示在路径上
  - 浏览器强制刷新参数会被清空
- query
  - 参数会显示在路径上，刷新不会被清空
  - name 可以使用 path 路径

##### vue-router 有哪几种导航守卫

- 全局前置守卫： `router.beforeEach`
- 全局解析守卫： `router.beforeResolve`
- 全局后置钩子： `router.afterEach`
- 路由独享的守卫： `beforeEnter`
- 组件内的守卫： `beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave`

##### vuex 的理解

​ vuex 是一个专为 vue.js 应用程序开发的状态管理模式，核心是响应式的做到数据管理。应用遇到多个组件共享状态时，使用 vuex。

​ vuex 有 5 种状态属性：State, Getter, Mutation, Action, Module

- state：存储数据，存储状态
- getters：可以认为是 store 的计算属性，它的返回值会根据它的依赖被缓存起来，只有当它的依赖值发生了变化才会重新被计算
- mutations：更改 store 中状态 state 的唯一方式就是提交 mutation
- actions：包含任意异步操作，通过提交 mutation 间接更变状态 state
- module：将 store 分割成模块，每个模块都有 state，mutations，getters，actions，module

​ vuex 的运行过程：组件派发任务到 actions，actions 触发 mutations 中的方法，然后 mutations 来改变 state 中的数据，数据变更后响应推送给组件，组件重新渲染

##### this 的问题

​ 任何函数本质上都是通过某个对象来调用的，如果没有直接指定那就是 window，所有函数内部都有一个变量 this。this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象。

​ 如何确定 this 的值：

- test(): window
- p.test(): p
- new test(): 新创建的对象
- test.call(obj): obj

##### let 和 const（var 和 let 的区别）

​ let 和 const 相同的部分：

- 存在块级作用域
- 不存在变量提升，但 var 会提升
- 暂时性死区
- 不允许重复声明

​ 此外 const 一定要赋初始值，常量的值不能修改

##### htmls5 新特性

- 拖放（Drag and drop）API
- 语义化标签（header、nav、footer、section、article、aside）
- 音频、视频（audio、video）API
- 画布（canvas）API
- 地理定位（Geolocation) API
- 本地离线存储（localStorage），即长期存储数据，浏览器关闭后数据不丢失
- 会话存储（sessionStorage），即数据在浏览器关闭后自动删除
- 表单控件（calender，date，time，url，email，search）
- 新的技术（webworker、websocket）

##### websocket 和 ajax 的区别

- 本质不同

  Ajax,即异步 JavaScript 和 XML，是一种创建交互式网页应用的网页开发技术；

  WebSocket 是 HTML5 一种新的协议，实现了浏览器与服务器全双工通信。其本质是先通过 HTTP/HTTPS 协议进行握手后创建一个用于交换数据的 TCP 连接，服务端与客户端通过此 TCP 连接进行实时通信。

- 生命周期不同

  websocket 建立的是长连接，在一个会话中一直保持连接；而 ajax 是短连接，数据发送和接受完成后就会断开连接。

- 适用范围不同

  websocket 一般用于前后端实时数据交互，而 ajax 前后端非实时数据交互。

- 发起人不同

  Ajax 技术需要客户端发起请求，而 WebSocket 服务器和客户端可以相互推送信息。

##### 箭头函数

- this 是静态的，this 始终指向函数定义时所在作用域下的 this 的值
- 箭头函数中的 this 是在定义函数的时候绑定的，而不是在执行函数的时候绑定
- 箭头函数中，this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this，正是因为他没有 this，所以也就不能用作构造函数
- 不能作为构造函数实例化对象
- 不能使用 arguments 变量（可使用 rest 参数...）
- 箭头函数通过 call 和 apply 调用，不会改变 this 指向，只会传入参数

​ 箭头函数适合与 this 无关的回调：定时器，数组的方法回调

​ 不适合与 this 有关的回调：事件回调，对象的方法

##### div+css 的布局较 table 布局有什么优点

​ 1.代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。

​ 2.布局精准，网站版面布局修改简单。

​ 3.加快了页面的加载速度（最重要的）。

​ 4.节约站点所占的空间和站点的流量。

​ 5.用只包含结构化内容的 HTML 代替嵌套的标签，提高搜索引擎对网页的搜索效率。

##### 例举 3 种强制类型转换和 2 种隐式类型转换

​ 强制类型转换：parseInt(), parseFloat(), Number()

​ 隐式类型转换：==，+， -

##### css 优先级

​ 样式的引用方式对 css 优先级的影响：

​ 行内样式（写在标签的 style 属性中） > 内部样式表（写在头部的 style 标签中） > 外部样式表（通过 link 标签引用 css 文件）

​ 但是有!important 的样式除外

​ 选择器对 css 样式优先级的影响：

​ !important > id 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 > 通配选择符 = 关系选择符

##### webpack 优化（提高 webpack 构建速度方法）

​ https://zhuanlan.zhihu.com/p/102391654

- 优化打包速度
  - 合理配置 mode 参数与 devtool 参数
  - 缩小文件的搜索范围（配置 include exclude alias noParse extensionswebpack）
  - 使用 HappyPack 开启多进程 Loader 转换
  - 使用 webpack-parallel-uglify-plugin 增强代码压缩
  - 使用 webpack 内置的 DllPlugin DllReferencePlugin 抽离第三方模块
  - 配置缓存（大部分 loader 提供了 cache 配置项，也可以通过 cache-loader）
- 优化打包体积
  - 引入 webpack-bundle-analyzer 分析打包后的文件
  - 使用 externals 将不需要打包的静态资源从构建逻辑中剔除，而使用 CDN 去引用它们
  - 使用 tree-shaking 清除无用代码（目前 webpack4 中设置 mode 为 production 时自动开启 tree-shaking）

##### js 中的回调地狱和解决方法

​ 在使用 JavaScript 时，为了实现某些逻辑经常会写出层层嵌套的回调函数，如果嵌套过多，会极大影响代码可读性和逻辑，这种情况也被成为回调地狱。

​ 解决回调地狱的方法：

- Promise
- Generator(生成器)
- async/await

##### js 中的深浅拷贝

- 赋值：当我们把一个对象赋值给一个新的变量的时候，赋的其实是该对象在栈中的地址，而不是堆中的数据，也就是两个对象指向的是同一个存储空间，无论哪个对象发生变化，其实都是改变的存储空间的内容，因此两个对象是联动的

- 浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存会相互影响

- 深拷贝：从堆中开辟一块新的区域存放对象，原始对象和新对象之间互不影响

  ```javascript
  //赋值代码
  var person = {
    name: "张三",
    hobby: ["学习", "敲代码", "吃西瓜"],
  }
  var person1 = person
  ```

  ```javascript
  //浅拷贝代码
  var person = {
    name: "张三",
    hobby: ["学习", "敲代码", "吃西瓜"],
  }
  function shallowCopy(obj) {
    var target = {}
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        target[i] = obj[i]
      }
    }
    return target
  }
  var person1 = shallowCopy(person)
  ```

  ```javascript
  //深拷贝代码
  var person = {
    name: "张三",
    hobby: ["学习", "敲代码", "吃西瓜"],
  }
  function deepClone(obj) {
    var cloneObj = new obj.constructor()
    if (obj === null) return obj
    if (obj instanceof Date) return new Date(obj)
    if (obj instanceof RegExp) return new RegExp(obj)
    if (typeof obj !== "object") return obj
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        cloneObj[i] = deepClone(obj[i])
      }
    }
    return cloneObj
  }
  ```

  - 浅拷贝的实现方式

    Object.assign()

    lodash 里的\_.clone()

    ...展开运算符

    Array.prototype.concat()

    Array.prototype.slice()

  - 深拷贝的实现方式

    JSON.parse(JSON.stringify())

    递归操作

    lodash 里的\_.cloneDeep()

    jquery.extend()

##### cookie 和 session 的区别

​ 1、数据存放位置不同：

​ cookie 数据存放在客户的浏览器上，session 数据放在服务器上。

​ 2、安全程度不同：

​ cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗,考虑到安全应当使用 session。

​ 3、性能使用程度不同：

​ session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用 cookie。

​ 4、数据存储大小不同：

​ 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie，而 session 则存储与服务端，浏览器对其没有限制。

##### 请求方法 head 特性

​ HEAD 方法是向服务器发出指定资源的请求，只不过**索要的只是响应头，响应体将不会被返回**。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。

​ 有以下特点：

​ 1、只请求资源的首部；

​ 2、检查超链接的有效性；

​ 3、检查网页是否被修改；

​ 4、多用于自动搜索机器人获取网页的标志信息，获取 rss 种子信息，或者传递安全认证信息等

##### tcp 和 udp 有什么区别

​ tcp 比 udp 可靠，它提供的是面向连接、可靠的数据流传输，且有超时重发的功能，而 udp 不一定提供可靠的数据传输。

##### tree-shaking

​ tree-shaking 的本质是消除无用的 js 代码。

​ tree-shaking 是 DCE 的一种新的实现，但是传统的 DCE 消灭不可能执行的代码，而 tree-shaking 更关注于消除没有用到的代码。将无用的代码删除，减少 js 包的大小，从而减少用户等待的时间

​ tree shaking 得以实现，是依赖 es6 的 module 模块的。tree shaking 首先会分析文件项目里具体哪些代码被引入了，哪些没有引入，然后将真正引入的代码打包进去，最后没有使用到的代码自然就不会存在了。

​ 需要配置 `{ module: false }`和 `sideEffects: false`

##### common.js 和 es6 module 的区别

- commonjs 是被加载的时候运行，esmodule 是编译的时候运行
- commonjs 输出的是值的浅拷贝，esmodule 输出值的引用
- coomonjs 是单个值导出，esmodule 可以导出多个

##### v-if 和 v-show 的区别

- v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
- v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做--直到条件第一次变为真时，才会开始渲染条件块。
- 相比之下，v-show 简单得多。不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 css 进行切换。
- 一般来说，v-if 有更高地切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 比较好，如果在运行时条件很少改变，则使用 v-if 较好。

##### 301，302，307，308 的区别

- 301 moved permanently 永久移动

- 302 found 发现

- 307 temporary redirect 临时重定向

- 308 permanent redirect 永久重定向

  区别

  - 301，302 是 http1.0 的内容，307，308 是 http1.1 的内容
  - 301、308 是永久改变地址；302、307 是临时改变地址
  - 301、302 允许改变请求方法（post 会改 get）；308、307 不允许改变请求方法（post 方法还是 post 方法）

##### 点击穿透问题

​ 假如页面上有两个元素 A 和 B。B 元素在 A 元素之上。我们在 B 元素的 touchstart 事件上注册了一个回调函数，该回调函数的作用是隐藏 B 元素。我们发现，当我们点击 B 元素，B 元素被隐藏了，随后，A 元素触发了 click 事件。

​ 这是因为在移动端浏览器，事件执行的顺序是 touchstart > touchmove > touchend > click。而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，就算解决了这个由于执行顺序一样会穿透，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。

​ 点击穿透的三种情况：

- 点击穿透问题：点击蒙层（mask）上的关闭按钮，蒙层消失后发现触发了按钮下面元素的 click 事

  件。

- 跨页面点击穿透问题：如果按钮下面恰好是一个有 href 属性的 a 标签，那么页面就会发生跳转因为 a 标签跳转默认是 click 事件触发 ，所以原理和上面的完全相同

- 点击穿透问题：这次没有 mask 了，直接点击页内按钮跳转至新页，然后发现新页面中对应位置元

  素的 click 事件被触发了。

​ 解决办法：

- 延长弹窗关闭的事件，比如让弹窗 300ms 以上渐变消失（也可以用定时器）
- touchstart 里面阻止默认事件，会阻止默认的 click 事件的创建
- css 的 pointer-events:none 来禁掉元素的点击事件，300ms 之后恢复
- 使用 fastclick 库（FastClick 的实现原理是在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即出发模拟一个 click 事件，并把浏览器在 300ms 之后的 click 事件阻止掉。）

##### HTTP 请求包括哪几个部分

​ 1.请求报文(请求行/请求头/空行/请求数据)

- 请求行

  请求方法字段、URL 字段和 HTTP 协议版本

  ​ 例如：GET /index.html HTTP/1.1

  ​ get 方法将数据拼接在 url 后面，传递参数受限

  请求方法：

  ​ GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT

- 请求头(key value 形式)

​ User-Agent：产生请求的浏览器类型。

​ Accept：客户端可识别的内容类型列表。

​ Host：主机地址

​ Content-Type：请求体的 MIME 类型 （用于 POST 和 PUT 请求中）

- 空行

​ 发送回车符和换行符，通知服务器以下不再有请求头

- 请求数据

​ post 方法中，会把数据以 key value 形式发送请求

​ 请求数据不在 GET 方法中使用，而是在 POST 方法中使用。POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。

​ 例如：

​ GET /sample.jsp HTTP/1.1

​ Accept:image/gif.image/jpeg,_/_

​ Accept-Language:zh-cn

​ Connection:Keep-Alive

​ Host:localhost

​ User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)

​ Accept-Encoding:gzip,deflate

​

​ username=jinqiao&password=1234

​ 2.响应报文(状态行/响应头/空行/响应正文)

- 状态行

  由 http 版本 + 状态码 + 状态代码的文本描述三个部分组成

  例如 HTTP/1.1 200 ok

- 响应头

  包含服务器类型，日期，长度，内容类型等

  Server:Apache Tomcat/5.0.12

  Date:Mon,6Oct2003 13:13:33 GMT

  Content-Type:text/html

  Last-Moified:Mon,6 Oct 2003 13:23:42 GMT

  Content-Length:112

- 空行

- 响应正文

  就是服务器返回的 HTML 页面或者 json 数据

##### null 和 undefined 的区别

- Number 转换的值不同

  ```javascript
  console.log(Number(null)) //0
  console.log(Number(undefined)) //NaN
  console.log(parseInt(undefined)) //NaN
  console.log(parseInt(null)) //NaN
  ```

- null 表示一个对象被定义了，但这个值是空值 null

  undefined 表示一个变量申明了但是没有赋初始值

- typeof undefined //"undefined"

  typeof null //"object"

##### vue 和 react 的区别

- Vue 本质是 MVVM 框架，由 MVC 发展而来；React 是前端组件化框架，由后端组件化发展而来；

##### promise 错误处理的方法

- then(resolve,reject); then 方法中第二个回调,是失败时候做的失败时候做的事
- 使用 catch 捕获错误

##### vue 和 react 区别

相同点

- 都支持服务器端渲染
- 都有 virtual dom，组件化开发，通过 props 参数进行父子组件数据传递，都实现 webComponent 规范
- 数据驱动视图
- 都有支持 native 的方案，react 的 react native，vue 的 weex

不同点

- react 严格上只针对 MVC 的 view 层，vue 是 MVVM 模式
- virtual dom 不一样，vue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树，react 每当应用的状态被改变时，全部组件都会重新渲染
- 组件写法不一样，react 是把 html，css 全部写进 js 了，即‘all in js’，vue 是把 html，css，js 写在同一个文件中，且各种分开
- 数据绑定，vue 实现了数据的双向绑定，react 数据流动是单向的
- state 对象在 react 应用中不可变的，需要使用 setState 方法更新状态，在 vue 中，state 对象不是必须的，数据由 data 属性在 vue 对象中管理。、

##### uniapp 生命周期

应用生命周期

- onLaunch 当`uni-app` 初始化完成时触发（全局只触发一次）
- onShow 当 `uni-app` 启动，或从后台进入前台显示
- onHide 当 `uni-app` 从前台进入后台

页面生命周期

- onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参）
- onShow 监听页面显示
- onReady 监听页面初次渲染完成。
- onHide 监听页面隐藏
- onUnload 监听页面卸载
- onResize 监听窗口尺寸变化

##### 栈和队列

- 栈（stack）：先进后出，删除与加入均在栈顶操作，是一种线性表；
- 队列 ：也是一种特殊的线性表，先进先出，队列在队头做删除操作，在队尾做插入操作。

##### 算法题

##### 冒泡排序

升序为例：相邻两个节点比较，如果前者比后者大，则交换两个位置

- 时间复杂度

  最好的情况：数组本身是顺序的，外层循环遍历一次就完成 O(n)

  最坏的情况：数组本身是逆序的，内外层遍历 O(n^2)

  平均情况：O(n^2)

- 空间复杂度

  开辟一个空间交换顺序 O(1)

- 稳定性

  稳定，因为 if 判断不成立，就不会交换顺序，不会交换相同元素。

```javascript
function bubbleSort(arr) {
  var len = arr.length
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        //[arr[j], arr[j+1]] = [arr[j+1], arr[j]]
        var temp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = temp
      }
    }
  }
  return arr
}
```

##### 选择排序

升序为例

第一轮：遍历整个数组找到最小的一个，将其与第一个位置交换

第二轮：遍历除开第一个元素之外的其他元素，将找的最小的值与第二个值交换

第三轮：循环往复。。。

- 时间复杂度

  最好的情况：O(n^2)

  最坏的情况： O(n^2)

  平均情况：O(n^2)

- 空间复杂度

  O(1)

- 稳定性

  不稳定

```javascript
function selectSort(arr) {
  let minIndex
  let len = arr.length
  for (let i = 0; i < len - 1; i++) {
    minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    ;[arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
  }
  return arr
}
```

##### 插入排序

从第一个元素开始，该元素可以认为已经被排序；

取出下一个元素，在已经排序的元素序列中从后向前扫描；

如果该元素（已排序）大于新元素，将该元素移到下一位置；

重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；

将新元素插入到该位置后；

重复步骤 2~5。

- 时间复杂度

  最好的情况：O(n)

  最坏的情况： O(n^2)

  平均情况：O(n^2)

- 空间复杂度

  O(1)

- 稳定性

  稳定

```javascript
function insertSort(arr) {
  var len = arr.length
  var preIndex, curVal
  for (let i = 1; i < len; i++) {
    preIndex = i - 1
    curVal = arr[i]
    while (preIndex >= 0 && arr[preIndex] > curVal) {
      arr[preIndex + 1] = arr[preIndex]
      preIndex--
    }
    arr[preIndex + 1] = curVal
  }
  return arr
}
```

##### 快速排序

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

从数列中挑出一个元素，称为 “基准”（pivot）；

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

- 时间复杂度

  最好的情况：O(nlog2^n)

  最坏的情况： O(n^2)

  平均情况：O(nlog2^n)

- 空间复杂度

  O(nlog2^n)

- 稳定性

  不稳定

```javascript
function quickSort(arr) {
  if (arr.length == 1 || arr.length == 0) {
    return arr
  }
  let index = Math.max(arr.length / 2)
  let current = arr.splice(index, 1)
  let leftArr = []
  let rightArr = []
  arr.forEach((item) => {
    if (item <= current) {
      leftArr.push(item)
    } else {
      rightArr.push(item)
    }
  })
  return quickSort(leftArr).concat(current).concat(quickSort(rightArr))
}
```

##### 归并排序

先递归的分解数列，再合并数列。

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。

把长度为 n 的输入序列分成两个长度为 n/2 的子序列；

对这两个子序列分别采用归并排序；

将两个排序好的子序列合并成一个最终的排序序列。

- 时间复杂度

  最好的情况：O(nlog2^n)

  最坏的情况： O(nlog2^n)

  平均情况：O(nlog2^n)

- 空间复杂度

  O(n)

- 稳定性

  稳定

```javascript
function merger(a, b) {
  var n = a && a.length
  var m = b && b.length
  var i = 0,
    j = 0
  var c = []
  while (i < n && j < m) {
    if (a[i] < b[j]) {
      c.push(a[i++])
    } else {
      c.push(b[j++])
    }
  }
  while (i < n) {
    c.push(a[i++])
  }
  while (j < m) {
    c.push(b[j++])
  }
  return c
}
function mergeSort(arr) {
  if (arr.length == 1) {
    return arr
  }
  var mid = Math.floor(arr.length / 2)
  var left = arr.slice(0, mid)
  var right = arr.slice(mid)
  return merger(mergeSort(left), mergeSort(right))
}
```

##### 反转链表

定义一个函数，输入链表的头节点，反转该链表并输出反转后的链表的头节点

```javascript
//输入: 1->2->3->4->5->NULL
//输出: 5->4->3->2->1->NULL
function reverse(head) {
  var cur = head
  var pre = null
  while (cur) {
    var temp = cur.next
    cur.next = pre
    pre = cur
    cur = temp
  }
  return pre
}
```

##### 删除链表节点

```javascript
function deleteNode(head, val) {
  ////判断删除的是否头节点
  if (head.val == val) {
    head = head.next
    return head
  }
  //如果不是头节点那么开始遍历
  //双指针
  var pre = head
  var cur = head.next
  while (cur) {
    if (cur.val == val) {
      pre.next = cur.next
      break
    }
    pre = cur
    cur = cur.next
  }
  return head
}
```

##### 两个链表的第一个公共节点

两个如何才能相遇喃。。。。走的路程一样就会相遇了。。。如何走的路程一样，循环走，我走完我的再走你的，你走完你的再走我的。。。。

```javascript
function getIntersectionNode(headA, headB) {
  let node1 = headA
  let node2 = headB
  while (node1 != node2) {
    if (node1 == null && node2 == null) break
    node1 = node1 ? node1.next : headB
    node2 = node2 ? node2.next : headA
  }
  return node1
}
```

##### 复杂链表的复制

```javascript
function copyRandomList(head) {
  if (!head) return head
  let map = new Map()
  let node = head
  while (node) {
    map.set(node, new Node(node.val))
    node = node.next
  }
  node = head
  while (node) {
    map.get(node).next = map.get(node.next) === undefined ? null : map.get(node.next)
    map.get(node).random = map.get(node.random)
    node = node.next
  }
  return map.get(head)
}
```

##### 二分查找

```javascript
function binSearch(arr, target) {
  let min = 0,
    max = arr.length - 1
  while (min <= max) {
    let mid = Math.floor((max + min) / 2)
    if (arr[mid] == target) return mid
    if (arr[mid] > target) {
      max = mid - 1
    } else {
      min = mid + 1
    }
  }
  return -1
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(binSearch(arr, 10))
```

##### 最长相同元素子串

```javascript
function maxSublen(str) {
  let max = 0
  let count = 0
  let left = 0
  let right = 0
  if (str.length == 0) return 0
  if (str.length == 1) return 1
  while (right !== str.length) {
    while (str[left] == str[right]) {
      count++
      right++
    }
    max = Math.max(count, max)
    left = right
    count = 0
  }
  return max
}
var str = "abcaaaacbbbbbbbbbd"
console.log(maxSublen(str))
```

##### 数组中重复的数字

在一个长度为 n 的数组 nums 里的所有数字都在 0-n-1 的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字

```javascript
function repeatNum(nums) {
  let map = new Map()
  for (let i = 0; i < nums.length; i++) {
    if (map.has(nums[i])) {
      return nums[i]
    } else {
      map.set(nums[i], 1)
    }
  }
  return false
}
```

##### 连续子数组的最大和

```javascript
function maxSubArr(arr) {
  let pre = 0
  let max = arr[0]
  arr.forEach((item) => {
    pre = Math.max(pre + item, item)
    max = Math.max(max, pre)
  })
  return max
}
console.log(maxSubArr([-2, 1, -3, 4, -1, 2, 1, -5, 4]))
```

##### 数组所有子集

```javascript
function getAllSubsets(arr) {
  return arr.reduce(
    (pre, cur) => {
      return pre.concat(pre.map((item) => [cur, ...item]))
    },
    [[]]
  )
}
console.log(getAllSubsets([1, 2, 3]))
```

##### 在排序数组中查找数字

```javascript
function search(arr, target) {
  let index = searchNum(arr, target)
  if (index == -1) return 0
  let count = 1
  for (let i = index + 1; i < arr.length; i++) {
    if (arr[i] == target) {
      count++
    } else {
      break
    }
  }
  for (let j = index - 1; j >= 0; j--) {
    if (arr[j] == target) {
      count++
    } else {
      break
    }
  }
  return count
}
function searchNum(arr, target) {
  let left = 0
  let right = arr.length - 1
  while (left <= right) {
    let mid = Math.floor((left + right) / 2)
    if (arr[mid] == target) {
      return mid
    } else if (arr[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return -1
}
```

##### 股票最大利润

```javascript
let arr = [7, 1, 5, 3, 6, 4]
function maxProfit(prices) {
  if (prices.length < 2) return 0
  let dp = []
  dp[0] = 0
  let mincost = prices[0]
  for (let i = 1; i < prices.length; i++) {
    dp[i] = Math.max(dp[i - 1], prices[i] - mincost)
    mincost = Math.min(mincost, prices[i])
  }
  return dp[prices.length - 1]
}
```

##### 求 1+2+3+...+n

```javascript
function sumNums(n) {
  return n && n + sumNums(n - 1)
}
```

##### 青蛙跳台阶问题

```javascript
function numWays(n) {
  if (n == 0) return 1
  if (n <= 2) return n
  return (numWays(n - 1) + numWays(n - 2)) % 1000000007
}
```

##### 斐波拉契数列

```javascript
function func(n) {
  if (n == 0 || n == 1) {
    return n
  } else {
    return func(n - 1) + func(n - 2)
  }
}
```

##### 礼物的最大价值

```javascript
function maxValue(grid) {
  let row = grid.length
  let col = grid[0].length
  let dp = new Array(row).fill(0).map((item) => new Array(col).fill(0))
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (i == 0 && j == 0) {
        dp[i][j] = grid[i][j]
      } else if (i == 0) {
        dp[i][j] = dp[i][j - 1] + grid[i][j]
      } else if (j == 0) {
        dp[i][j] = dp[i - 1][j] + grid[i][j]
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
      }
    }
  }
  return dp[row - 1][col - 1]
}
let grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1],
]
console.log(maxValue(grid))
```

##### 扑克牌中的顺子

- 最大值-最小值<5
- 没有重复值

```javascript
let nums = [0, 0, 1, 2, 5]
var isStraight = function (nums) {
  nums.sort((a, b) => a - b)
  let map = new Map()
  let min = 14
  let max = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] == 0) {
      continue
    }
    if (map.has(nums[i])) {
      return false
    }
    if (nums[i] > max) {
      max = nums[i]
    }
    if (nums[i] < min) {
      min = nums[i]
    }
    map.set(nums[i], 1)
  }
  return max - min < 5
}
```

##### 翻转单词顺序

```javascript
var reverseWords = function (s) {
  return s
    .split(" ")
    .filter((item) => item)
    .reverse()
    .join(" ")
}
let s = "a good   example"
```

##### 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字 2，该函数将返回左旋转两位得到的结果"cdefgab"。

```javascript
var reverseLeftWords = function (s, n) {
  return s.substring(n) + s.substring(0, n)
}
let s = "abcdefg",
  k = 2
console.log(reverseLeftWords(s, k)) //"cdefgab"
```

##### 圆圈中最后剩下的数字

约瑟夫环，数学解法

```javascript
var lastRemaining = function (n, m) {
  let ans = 0
  for (let i = 2; i <= n; i++) {
    ans = (ans + m) % i
  }
  return ans
}
```

##### 和为 s 的两个数字

```javascript
var twoSum = function (nums, target) {
  let p = 0
  let q = nums.length - 1
  let res = []
  while (p < q) {
    if (nums[p] + nums[q] < target) {
      p++
    }
    if (nums[p] + nums[q] > target) {
      q--
    }
    if (nums[p] + nums[q] == target) {
      res.push(nums[p])
      res.push(nums[q])
      return res
    }
  }
  return null
}
//输入：nums = [10,26,30,31,47,60], target = 40
//输出：[10,30] 或者 [30,10]
```

##### 和为 s 的连续正整数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

```javascript
function fun(target) {
  let p = 1
  let q = 1
  let sum = 0
  let res = []
  while (p <= target / 2) {
    if (sum < target) {
      sum = sum + q
      q++
    } else if (sum > target) {
      sum = sum - p
      p++
    } else {
      let tempArr = []
      for (let i = p; i < q; i++) {
        tempArr.push(i)
      }
      res.push(tempArr)
      sum = sum - p
      p++
    }
  }
  return res
}
console.log(fun(15)) //[[1,2,3,4,5],[4,5,6],[7,8]]
```

##### 0~n-1 中缺失的数字

利用数学公式

```javascript
function missingNumber(nums) {
  let len = nums.length
  let sum = ((0 + len) * (len + 1)) / 2
  let ans = nums.reduce((pre, cur) => {
    return pre + cur
  }, 0)
  return sum - ans
}
console.log(missingNumber([0, 1, 3]))
```

##### 有效括号

```javascript
var isValid = function (s) {
  let map = {
    "(": ")",
    "{": "}",
    "[": "]",
  }
  if (!s) {
    return true
  }
  let stack = []
  for (let i = 0; i < s.length; i++) {
    let ch = s[i]
    if (ch == "(" || ch == "{" || ch == "[") {
      stack.push(map[ch])
    } else {
      if (stack.pop() !== ch) {
        return false
      }
    }
  }
  return !stack.length
}
console.log(isValid("([)]")) //false
console.log(isValid("()[]{}")) //true
```

##### 用两个栈实现队列

```javascript
var CQueue = function () {
  this.stack1 = [] //在队尾插入元素
  this.stack2 = [] //在队头删除元素
}

/**
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function (value) {
  this.stack1.push(value)
}

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function () {
  if (!this.stack2.length) {
    if (!this.stack1.length) {
      return -1
    } else {
      while (this.stack1.length) {
        this.stack2.push(this.stack1.pop())
      }
    }
  }
  return this.stack2.pop()
}
```

##### 包含 min 函数的栈

```javascript
var MinStack = function () {
  this.stack = []
  this.min_stack = [Infinity]
}

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function (x) {
  this.stack.push(x)
  this.min_stack.push(Math.min(x, this.min_stack[this.min_stack.length - 1]))
}

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
  this.stack.pop()
  this.min_stack.pop()
}

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
  return this.stack[this.stack.length - 1]
}

/**
 * @return {number}
 */
MinStack.prototype.min = function () {
  return this.min_stack[this.min_stack.length - 1]
}
```

##### 创建二叉树

```javascript
let BiTree = function (ele) {
  this.data = ele
  this.left = null
  this.right = null
}
```

##### 前序遍历

```javascript
function preorderTraversal(root) {
  let res = []
  if (!root) return res
  preorder(root, res)
  return res
}
function preorder(node, res) {
  if (!node) return res
  res.push(node.val)
  preorder(node.left, res)
  preorder(node.right, res)
}
```

##### 中序遍历

```javascript
function inorderTraversal(root) {
  let res = []
  if (!root) return res
  inorder(root, res)
  return res
}
function inorder(node, res) {
  if (!node) return
  inorder(node.left, res)
  res.push(node.val)
  inorder(node.right, res)
}
```

##### 后序遍历

```javascript
function postorderTraversal(root) {
  let res = []
  postorder(root, res)
  return res
}
function postorder(node, res) {
  if (!node) return
  postorder(node.left, res)
  postorder(node.right, res)
  res.push(node.val)
}
```

##### 二叉树镜像

```javascript
function mirrorTree(root) {
  if (root) {
    ;[root.left, root.right] = [root.right, root.left]
    mirrorTree(root.left)
    mirrorTree(root.right)
  }
  return root
}
```

##### 对称的二叉树

```javascript
var isSymmetric = function (root) {
  if (!root) return true
  return answer(root.left, root.right)
}
function answer(node1, node2) {
  if (node1 == null && node2 == null) {
    return true
  }
  if (node1 == null || node2 == null) {
    return false
  }
  if (node1.val == node2.val && answer(node1.left, node2.right) && answer(node1.right, node2.left)) {
    return true
  } else {
    return false
  }
}
```

##### 最长不含重复字符的子字符串

```javascript
function lengthOfLongestSubstring(s) {
  let left = 0
  let right = 0
  let res = 0
  let map = new Map()
  while (right < s.length) {
    let cur = s[right]
    if (map.get(cur) >= 0) {
      left = Math.max(left, map.get(cur) + 1)
    }
    map.set(cur, right)
    res = Math.max(res, right - left + 1)
    right++
  }
  return res
}
```
