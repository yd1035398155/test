<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		#box {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 20px;
			writing-mode: vertical-lr;
			word-spacing: 20px;

		}

		body {
			background-color: cornflowerblue;

		}
	</style>

</head>

<body>
	<div id="box">
		答题区
		<textarea name="" id="" cols="30" rows="10"></textarea>
	</div>

	<!-- 代码区 -->
	<script>
		function myPromise(constructor) {
			let self = this;
			self.status = "pending" //定义状态改变前的初始状态 
			self.value = undefined;//定义状态为resolved的时候的状态 
			self.reason = undefined;//定义状态为rejected的时候的状态 
			function resolve(value) {
				//两个==="pending"，保证了了状态的改变是不不可逆的 
				if (self.status === "pending") {
					self.value = value;
					self.status = "resolved";
				}
			}
			function reject(reason) {
				//两个==="pending"，保证了了状态的改变是不不可逆的
				if (self.status === "pending") {
					self.reason = reason;
					self.status = "rejected";
				}
			}
			//捕获构造异常 
			try {
				constructor(resolve, reject);
			} catch (e) {
				reject(e);
			}
		}
		myPromise.prototype.then = function (onFullfilled, onRejected) {
			let self = this;
			switch (self.status) {
				case "resolved": onFullfilled(self.value); break;
				case "rejected": onRejected(self.reason); break;
				default:
			}
		}

		// 测试
		var p = new myPromise(function (resolve, reject) { resolve(1) });
		p.then(function (x) { console.log(x) })
//输出1

	</script>


	<script>
		/*
			 ## 创建对象的方法
			 * 1.工厂模式   函数内部new个对象 返回这个对象
			 function A(name){
				let o = new Object();
				o.name = name;
				return o;
			 }
			 * 2.构造函数模式  属性方法赋值给this
			 function A(name){
				 this.name = name;
			 }
			 let person = new A("YD");
			 * 3.原型模式   属性方法赋值给构造函数的原型
			 function A(){};
			 A.prototype.name="YD";

			 * 4.组合使用构造函数和原型模式   利用构造函数完成属性初始化,原型模式完成方法的共享
			 * 5.动态原型模式    与构造函数类似,但创建方法时,先判断这个函数是否存在
				function A(name){
					this.name = name;
					if(typeof this.sayname != 'function'){
						A.prototype.sayname = function(){
							console.log(this.name)
						}
					}
				};
			 * 6.寄生构造函数模式  与工厂相同,多了一个new.
			## 继承对象的方法
				1.原型继承   将子类的原型指向父类的实例
				2.借用构造函数继承   在子类内部调用父类构造函数,并用call(this),将执行上下文变为子函数
				3.组合式继承	利用1和2来继承
				4.原型式继承	利用已有对象
				5.寄生式继承
				6.组合寄生式继承
		*/

	</script>

</body>

</html>